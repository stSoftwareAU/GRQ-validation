<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    >
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GRQ Validation Dashboard v1.0.1</title>
    <link rel="icon" type="image/png" href="logo.png" />

    <!-- Bootstrap 5 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    >

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>

    <!-- Custom styles -->
    <link rel="stylesheet" href="styles.css">
  </head>
  <body class="bg-light">
    <div class="container-fluid">
      <div class="row">
        <div class="col-12">
          <div class="card shadow-sm border-0">
            <div class="card-header header-gradient text-white text-center py-4">
              <h1 class="display-4 mb-2">GRQ Validation Dashboard</h1>
              <p class="lead mb-0">
                Validating AI predictions against 90-day targets and 10% annual
                cost of capital
              </p>
            </div>

            <div class="card-body p-4">
              <!-- Controls -->
              <div class="row mb-4">
                <div class="col-md-6 col-lg-4">
                  <div class="mb-3">
                    <label for="scoreFileSelect" class="form-label fw-bold"
                    >Score File:</label>
                    <select id="scoreFileSelect" class="form-select">
                      <option value="">Select a score file...</option>
                    </select>
                  </div>
                </div>
              </div>

              <!-- Loading and Error Messages -->
              <div id="loading" class="loading text-center py-5">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3">Loading data...</p>
              </div>

              <div id="error" class="alert alert-danger" style="display: none">
              </div>
              <div id="noData" class="alert alert-info" style="display: none">
                No market data available yet for this score file. Data will
                appear as it becomes available.
              </div>

              <!-- Main Content -->
              <div id="summary" style="display: none">
                <!-- Chart -->
                <div class="row mb-4">
                  <div class="col-12">
                    <div class="d-flex justify-content-between align-items-center">
                      <h2 class="mb-0">Performance Chart</h2>
                      <button
                        id="backToAggregate"
                        class="btn btn-outline-primary"
                        style="display: none"
                      >
                        ‚Üê Back to Portfolio View
                      </button>
                    </div>
                  </div>
                </div>
                <div class="card mb-4">
                  <div class="card-body">
                    <div class="chart-container">
                      <canvas id="performanceChart"></canvas>
                    </div>
                  </div>
                </div>

                <!-- Stock Table -->
                <div class="card">
                  <div class="card-header">
                    <h5 class="card-title mb-0">
                      Individual Stock Performance
                    </h5>
                  </div>
                  <div class="card-body p-0">
                    <div class="table-responsive">
                      <table
                        class="table table-hover stock-table mb-0"
                        id="stockTable"
                      >
                        <thead>
                          <tr>
                            <th>Stock</th>
                            <th>Score</th>
                            <th>Buy Price</th>
                            <th>90-Day Target</th>
                            <th>Current Price</th>
                            <th>Gain/Loss (%)</th>
                            <th>Progress vs Cost of Capital</th>
                            <th>Judgement (90-day)</th>
                            <th>Intrinsic Value (Basic)</th>
                            <th>Intrinsic Value (Adjusted)</th>
                            <th>Ex-Dividend Date</th>
                            <th>Average Dividend (90-day)</th>
                            <th>Total Dividends (90-day)</th>
                            <th>Notes</th>
                          </tr>
                        </thead>
                        <tbody id="stockTableBody"></tbody>
                      </table>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js?v=1.0.1"></script>

    <script>
      class GRQValidator {
        constructor() {
          this.scoreData = null;
          this.marketData = null;
          this.dividendData = null;
          this.selectedFile = null;
          this.filteredStocks = [];
          this.selectedStock = null; // Track selected stock for single view
          this.chart = null;
          this.costOfCapital = 10; // 10% annual cost of capital

          this.initializeEventListeners();
          this.loadIndex();
        }

        initializeEventListeners() {
          document
            .getElementById("scoreFileSelect")
            .addEventListener("change", (e) => {
              this.selectedFile = e.target.value;
              this.selectedStock = null; // Reset to aggregate view
              if (this.selectedFile) {
                this.loadScoreFile();
              }
            });

          // Remove stock filter event listener - no longer needed

          // Add back to aggregate view button
          document.getElementById("backToAggregate").addEventListener(
            "click",
            () => {
              this.selectedStock = null;
              this.updateDisplay();
            },
          );

          // Global click handler to manage popover behavior
          document.addEventListener("click", (event) => {
            const popoverTrigger = event.target.closest(
              '[data-bs-toggle="popover"]',
            );
            const popoverContent = event.target.closest(".popover");

            // Don't do anything if clicking inside the popover content
            if (popoverContent) {
              return;
            }

            // Close all existing popovers
            const popovers = document.querySelectorAll(
              '[data-bs-toggle="popover"]',
            );
            popovers.forEach((element) => {
              const popover = bootstrap.Popover.getInstance(element);
              if (popover && element.hasAttribute("aria-describedby")) {
                popover.hide();
              }
            });

            // If we clicked on a popover trigger, show the new one after a brief delay
            if (popoverTrigger) {
              setTimeout(() => {
                const popover = bootstrap.Popover.getInstance(
                  popoverTrigger,
                );
                if (popover) {
                  popover.show();
                }
              }, 10);
            }
          });
        }

        async loadIndex() {
          try {
            // Add cache-busting parameter to force fresh fetch
            const timestamp = new Date().getTime();
            const response = await fetch(
              `scores/index.json?t=${timestamp}`,
            );
            const indexData = await response.json();

            const select = document.getElementById("scoreFileSelect");
            select.innerHTML =
              '<option value="">Select a score file...</option>';

            indexData.scores.forEach((score) => {
              const option = document.createElement("option");
              option.value = score.file;
              option.textContent =
                `${score.date} (${score.month} ${score.day})`;
              select.appendChild(option);
            });

            if (indexData.scores.length > 0) {
              this.selectedFile = indexData.scores[0].file;
              select.value = this.selectedFile;
              await this.loadScoreFile();
            }
          } catch (error) {
            this.showError(
              "Failed to load score files: " + error.message,
            );
          }
        }

        async loadScoreFile() {
          this.showLoading();

          try {
            await this.loadScoreData();
            await this.loadMarketData();
            this.updateDisplay();
          } catch (error) {
            this.showError("Failed to load data: " + error.message);
          }
        }

        async loadScoreData() {
          // Add cache-busting parameter
          const timestamp = new Date().getTime();
          const response = await fetch(
            `scores/${this.selectedFile}?t=${timestamp}`,
          );
          const text = await response.text();

          const lines = text.trim().split("\n");
          const headers = lines[0].split("\t");

          this.scoreData = lines.slice(1).map((line) => {
            const values = line.split("\t");
            return {
              stock: values[0],
              score: parseFloat(values[1]),
              target: parseFloat(values[2]),
              exDividendDate: values[3] || null,
              dividendPerShare: values[4] ? parseFloat(values[4]) : 0,
              notes: values[5] || "",
              intrinsicValuePerShareBasic: values[6]
                ? parseFloat(values[6])
                : null,
              intrinsicValuePerShareAdjusted: values[7]
                ? parseFloat(values[7])
                : null,
            };
          });

          // Initialize filtered stocks to all stocks (no filtering)
          this.filteredStocks = [...this.scoreData];
        }

        async loadMarketData() {
          const csvFile = this.selectedFile.replace(".tsv", ".csv");

          try {
            // Add cache-busting parameter
            const timestamp = new Date().getTime();
            const response = await fetch(
              `scores/${csvFile}?t=${timestamp}`,
            );
            const text = await response.text();

            if (!text.trim()) {
              this.marketData = null;
              return;
            }

            const lines = text.split("\n").filter((line) =>
              line.trim()
            );
            const headers = lines[0].split(",");

            this.marketData = {};

            lines.slice(1).forEach((line) => {
              const values = line.split(",");
              const date = values[0];
              const ticker = values[1];
              const high = parseFloat(values[2]);
              const low = parseFloat(values[3]);
              const open = parseFloat(values[4]);
              const close = parseFloat(values[5]);
              const splitCoefficient = parseFloat(values[6]);

              if (!this.marketData[ticker]) {
                this.marketData[ticker] = [];
              }

              this.marketData[ticker].push({
                date: new Date(date),
                high,
                low,
                open,
                close,
                splitCoefficient,
              });
            });

            // Load dividend data
            await this.loadDividendData();
          } catch (error) {
            console.warn(
              "No market data available yet:",
              error.message,
            );
            this.marketData = null;
          }
        }

        async loadDividendData() {
          const dividendFile = this.selectedFile.replace(
            ".tsv",
            "-dividends.csv",
          );

          try {
            // Add cache-busting parameter
            const timestamp = new Date().getTime();
            const response = await fetch(
              `scores/${dividendFile}?t=${timestamp}`,
            );
            const text = await response.text();

            if (!text.trim()) {
              this.dividendData = null;
              return;
            }

            const lines = text.split("\n").filter((line) =>
              line.trim()
            );
            const headers = lines[0].split(",");

            this.dividendData = {};

            lines.slice(1).forEach((line) => {
              const values = line.split(",");
              const exDivDate = values[0];
              const ticker = values[1];
              const amount = parseFloat(values[2]);

              if (!this.dividendData[ticker]) {
                this.dividendData[ticker] = [];
              }

              this.dividendData[ticker].push({
                exDivDate: new Date(exDivDate),
                amount,
              });
            });
          } catch (error) {
            console.warn(
              "No dividend data available:",
              error.message,
            );
            this.dividendData = null;
          }
        }

        updateDisplay() {
          if (!this.scoreData) {
            this.showError("No score data available");
            return;
          }

          if (
            !this.marketData ||
            Object.keys(this.marketData).length === 0
          ) {
            this.showNoData();
            return;
          }

          this.hideMessages();
          this.updateChart();
          this.updateStockTable();

          // Show/hide back button based on view mode
          document.getElementById("backToAggregate").style.display =
            this.selectedStock ? "block" : "none";

          // Apply CSS class for detailed view
          const tableContainer = document.querySelector(
            ".table-responsive",
          );
          if (this.selectedStock) {
            tableContainer.classList.add("stock-detail-view");
          } else {
            tableContainer.classList.remove("stock-detail-view");
          }
        }

        updateChart() {
          const ctx = document.getElementById("performanceChart")
            .getContext("2d");

          if (this.chart) {
            this.chart.destroy();
          }

          const chartData = this.prepareChartData();
          let chartTitle;
          if (this.selectedStock) {
            const stock = this.scoreData.find((s) =>
              s.stock === this.selectedStock
            );
            if (stock) {
              chartTitle = `${this.selectedStock} Performance (Score: ${
                stock.score.toFixed(3)
              }, Target: $${stock.target.toFixed(2)})`;
            } else {
              chartTitle = `${this.selectedStock} Performance`;
            }
          } else {
            chartTitle = "Portfolio Performance Over Time";
          }

          // Check if mobile device
          const isMobile = window.innerWidth <= 768;

          this.chart = new Chart(ctx, {
            type: "line",
            data: chartData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: {
                  display: true,
                  text: chartTitle,
                  font: {
                    size: isMobile ? 14 : 16,
                  },
                },
                legend: {
                  display: true,
                  position: "bottom",
                  labels: {
                    boxWidth: isMobile ? 12 : 16,
                    padding: isMobile ? 8 : 12,
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  callbacks: {
                    title: function (context) {
                      const date = new Date(context[0].parsed.x);
                      return date.toLocaleDateString();
                    },
                    label: function (context) {
                      const label = context.dataset.label || "";
                      const value = context.parsed.y;
                      const dataPoint = context.raw;

                      let tooltipText = "";
                      if (label.includes("Target")) {
                        tooltipText = `${label}: ${value.toFixed(1)}%`;
                      } else if (
                        label.includes("Price") &&
                        !label.includes("Performance")
                      ) {
                        tooltipText = `${label}: $${value.toFixed(2)}`;
                      } else if (label.includes("Actual")) {
                        tooltipText = `${label}: $${value.toFixed(2)}`;
                      } else {
                        tooltipText = `${label}: ${value.toFixed(1)}%`;
                      }

                      // Add dividend information if available
                      if (dataPoint && dataPoint.dividend) {
                        if (typeof dataPoint.dividend === "number") {
                          tooltipText += ` (Ex-Dividend: $${
                            dataPoint.dividend.toFixed(2)
                          })`;
                        } else {
                          tooltipText +=
                            ` (Ex-Dividend: ${dataPoint.dividend})`;
                        }
                      }

                      return tooltipText;
                    },
                  },
                },
              },
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "day",
                    displayFormats: {
                      day: isMobile ? "MMM d" : "MMM dd, yyyy",
                    },
                  },
                  title: {
                    display: true,
                    text: "Date",
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                  ticks: {
                    maxTicksLimit: isMobile ? 6 : 10,
                    font: {
                      size: isMobile ? 8 : 10,
                    },
                  },
                },
                y: {
                  type: "linear",
                  display: true, // Show for both single stock and aggregate view
                  position: "left",
                  beginAtZero: true,
                  title: {
                    display: true, // Show for both views
                    text: "Performance (%)",
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                  ticks: {
                    font: {
                      size: isMobile ? 8 : 10,
                    },
                    callback: function (value) {
                      return value + "%";
                    },
                  },
                },
                y1: {
                  type: "linear",
                  display: false, // Hide the right Y-axis since we're not using price values
                  position: "right",
                  beginAtZero: true,
                  title: {
                    display: false,
                    text: "Price ($)",
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                  ticks: {
                    font: {
                      size: isMobile ? 8 : 10,
                    },
                    callback: function (value) {
                      return "$" + value.toFixed(2);
                    },
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
              },
              plugins: {
                annotation: {
                  annotations: {
                    line1: {
                      type: "line",
                      xMin: this.getScoreDate(this.selectedFile),
                      xMax: this.getScoreDate(this.selectedFile),
                      borderColor: "rgba(255, 193, 7, 0.8)",
                      borderWidth: 2,
                      label: {
                        content: "Score Date",
                        enabled: true,
                        font: {
                          size: isMobile ? 8 : 10,
                        },
                      },
                    },
                    line2: {
                      type: "line",
                      yMin: 0,
                      yMax: 0,
                      borderColor: "rgba(108, 117, 125, 0.5)",
                      borderWidth: 1,
                    },
                    // Add 90-day target line
                    line3: {
                      type: "line",
                      xMin: new Date(
                        this.getScoreDate(this.selectedFile).getTime() +
                          (90 * 24 * 60 * 60 * 1000),
                      ),
                      xMax: new Date(
                        this.getScoreDate(this.selectedFile).getTime() +
                          (90 * 24 * 60 * 60 * 1000),
                      ),
                      borderColor: "rgba(220, 53, 69, 0.8)",
                      borderWidth: 2,
                      label: {
                        content: "90-Day Target",
                        enabled: true,
                        font: {
                          size: isMobile ? 8 : 10,
                        },
                      },
                    },
                  },
                },
              },
            },
          });
        }

        prepareChartData() {
          const datasets = [];
          const scoreDate = this.getScoreDate(this.selectedFile);
          const daysElapsed = this.getDaysElapsed(scoreDate);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );

          if (this.selectedStock) {
            // Single stock view
            const stock = this.scoreData.find((s) =>
              s.stock === this.selectedStock
            );
            if (stock) {
              const marketData = this.marketData[stock.stock];
              if (marketData && marketData.length > 0) {
                // Split data into before and after 90 days
                const before90Days = [];
                const after90Days = [];

                // Get the price on the score date as the buy price
                const scoreDateData = marketData.find((point) => {
                  // Compare dates by day only, ignoring time components
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                });
                const buyPrice = scoreDateData
                  ? this.adjustHistoricalPriceToCurrent(
                    (scoreDateData.high + scoreDateData.low) / 2,
                    stock.stock,
                    scoreDate,
                  )
                  : this.adjustHistoricalPriceToCurrent(
                    stock.target,
                    stock.stock,
                    scoreDate,
                  );

                // Get dividend data for this stock
                const stockDividends =
                  this.dividendData?.[stock.stock] || [];
                const exDivDates = stockDividends.map((d) =>
                  d.exDivDate.getTime()
                );

                marketData.forEach((point) => {
                  // Use split-adjusted price for chart
                  const adjustedPrice = this
                    .adjustHistoricalPriceToCurrent(
                      (point.high + point.low) / 2,
                      stock.stock,
                      point.date,
                    );
                  const dataPoint = {
                    x: point.date,
                    y: ((adjustedPrice - buyPrice) / buyPrice) * 100,
                  };

                  // Check if this is an ex-dividend date
                  const pointDateOnly = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const isExDivDate = exDivDates.some((exDivTime) => {
                    const exDivDateOnly = new Date(
                      new Date(exDivTime).getFullYear(),
                      new Date(exDivTime).getMonth(),
                      new Date(exDivTime).getDate(),
                    );
                    return pointDateOnly.getTime() ===
                      exDivDateOnly.getTime();
                  });

                  // Add dividend info to tooltip
                  if (isExDivDate) {
                    const dividend = stockDividends.find((d) => {
                      const dDateOnly = new Date(
                        d.exDivDate.getFullYear(),
                        d.exDivDate.getMonth(),
                        d.exDivDate.getDate(),
                      );
                      return dDateOnly.getTime() ===
                        pointDateOnly.getTime();
                    });
                    if (dividend) {
                      dataPoint.dividend = dividend.amount;
                    }
                  }

                  if (point.date <= ninetyDayDate) {
                    before90Days.push(dataPoint);
                  } else {
                    after90Days.push(dataPoint);
                  }
                });

                // Add before 90 days data (normal color)
                if (before90Days.length > 0) {
                  datasets.push({
                    label: stock.stock,
                    data: before90Days,
                    borderColor: "rgba(102, 126, 234, 1)",
                    backgroundColor: "rgba(102, 126, 234, 0.1)",
                    borderWidth: 3,
                    fill: false,
                    pointRadius: before90Days.map((point) =>
                      point.dividend ? 8 : 3
                    ),
                    pointBackgroundColor: before90Days.map((point) =>
                      point.dividend
                        ? "rgba(0, 123, 255, 1)"
                        : "rgba(102, 126, 234, 1)"
                    ),
                  });
                }

                // Add after 90 days data (ghosted/gray)
                if (after90Days.length > 0) {
                  datasets.push({
                    label: `${stock.stock} (After 90 Days)`,
                    data: after90Days,
                    borderColor: "rgba(108, 117, 125, 0.5)",
                    backgroundColor: "rgba(108, 117, 125, 0.1)",
                    borderWidth: 1,
                    fill: false,
                    pointRadius: after90Days.map((point) =>
                      point.dividend ? 8 : 3
                    ),
                    pointBackgroundColor: after90Days.map((point) =>
                      point.dividend
                        ? "rgba(108, 117, 125, 0.8)"
                        : "rgba(108, 117, 125, 0.5)"
                    ),
                  });
                }

                // Add target percentage as a single point at 90 days
                const targetPercentage = ((stock.target - buyPrice) / buyPrice) * 100;
                console.log(`Target calculation for ${stock.stock}:`, {
                  stockTarget: stock.target,
                  buyPrice: buyPrice,
                  targetPercentage: targetPercentage,
                  calculation: `((${stock.target} - ${buyPrice}) / ${buyPrice}) * 100 = ${targetPercentage}%`
                });
                datasets.push({
                  label: "Target",
                  data: [{
                    x: ninetyDayDate,
                    y: targetPercentage, // Use calculated target percentage
                  }],
                  borderColor: "rgba(255, 193, 7, 0.8)",
                  backgroundColor: "rgba(255, 193, 7, 0.8)",
                  borderWidth: 3,
                  pointRadius: 6,
                  pointHoverRadius: 8,
                  fill: false,
                  showLine: false, // Don't connect points
                });

                // Add intrinsic value shading if both values are available
                if (stock.intrinsicValuePerShareBasic !== null && stock.intrinsicValuePerShareAdjusted !== null) {
                  const adjustedBasicValue = this.adjustHistoricalPriceToCurrent(
                    stock.intrinsicValuePerShareBasic,
                    stock.stock,
                    scoreDate,
                  );
                  const adjustedAdjustedValue = this.adjustHistoricalPriceToCurrent(
                    stock.intrinsicValuePerShareAdjusted,
                    stock.stock,
                    scoreDate,
                  );
                  
                  const basicPercentage = ((adjustedBasicValue - buyPrice) / buyPrice) * 100;
                  const adjustedPercentage = ((adjustedAdjustedValue - buyPrice) / buyPrice) * 100;
                  
                  // Only show shading if both intrinsic values are positive
                  if (basicPercentage > 0 && adjustedPercentage > 0) {
                    // Determine which is higher and which is lower
                    const lowerValue = Math.min(basicPercentage, adjustedPercentage);
                    const higherValue = Math.max(basicPercentage, adjustedPercentage);
                    
                    // Create the lower boundary line with fill to the upper line
                    datasets.push({
                      label: "Intrinsic Value (Lower)",
                      data: [
                        { x: scoreDate, y: lowerValue },
                        { x: ninetyDayDate, y: lowerValue }
                      ],
                      borderColor: "rgba(40, 167, 69, 0.8)",
                      backgroundColor: "rgba(40, 167, 69, 0.1)",
                      borderWidth: 2,
                      fill: '+1', // Fill to the next dataset (upper boundary)
                      pointRadius: 0,
                      showLine: true,
                      tension: 0,
                    });
                    
                    // Create the upper boundary line
                    datasets.push({
                      label: "Intrinsic Value (Upper)",
                      data: [
                        { x: scoreDate, y: higherValue },
                        { x: ninetyDayDate, y: higherValue }
                      ],
                      borderColor: "rgba(40, 167, 69, 0.8)",
                      backgroundColor: "rgba(40, 167, 69, 0.1)",
                      borderWidth: 2,
                      fill: false,
                      pointRadius: 0,
                      showLine: true,
                      tension: 0,
                    });
                  }
                }
              }
            }
          } else {
            // Aggregate view - show portfolio average
            const portfolioData = this.calculatePortfolioData();
            if (portfolioData.length > 0) {
              // Split portfolio data into before and after 90 days
              const before90Days = [];
              const after90Days = [];
              portfolioData.forEach((point) => {
                if (point.x <= ninetyDayDate) {
                  before90Days.push(point);
                } else {
                  after90Days.push(point);
                }
              });

              // Add before 90 days data (normal color)
              if (before90Days.length > 0) {
                datasets.push({
                  label: "Portfolio Performance",
                  data: before90Days,
                  borderColor: "rgba(102, 126, 234, 1)",
                  backgroundColor: "rgba(102, 126, 234, 0.1)",
                  borderWidth: 3,
                  fill: false,
                  pointRadius: before90Days.map((point) =>
                    point.dividend ? 8 : 3
                  ),
                  pointBackgroundColor: before90Days.map((point) =>
                    point.dividend
                      ? "rgba(0, 123, 255, 1)"
                      : "rgba(102, 126, 234, 1)"
                  ),
                  pointBorderColor: before90Days.map((point) =>
                    point.dividend
                      ? "rgba(0, 123, 255, 1)"
                      : "rgba(102, 126, 234, 1)"
                  ),
                  pointHoverRadius: before90Days.map((point) =>
                    point.dividend ? 12 : 6
                  ),
                });
              }

              // Add after 90 days data (ghosted/gray)
              if (after90Days.length > 0) {
                datasets.push({
                  label: "Portfolio Performance (After 90 Days)",
                  data: after90Days,
                  borderColor: "rgba(108, 117, 125, 0.5)",
                  backgroundColor: "rgba(108, 117, 125, 0.1)",
                  borderWidth: 1,
                  fill: false,
                  pointRadius: after90Days.map((point) =>
                    point.dividend ? 8 : 3
                  ),
                  pointBackgroundColor: after90Days.map((point) =>
                    point.dividend
                      ? "rgba(108, 117, 125, 0.8)"
                      : "rgba(108, 117, 125, 0.5)"
                  ),
                  pointBorderColor: after90Days.map((point) =>
                    point.dividend
                      ? "rgba(108, 117, 125, 0.8)"
                      : "rgba(108, 117, 125, 0.5)"
                  ),
                  pointHoverRadius: after90Days.map((point) =>
                    point.dividend ? 12 : 6
                  ),
                });
              }

              // Add portfolio target as a single point at 90 days
              const portfolioTarget = this
                .calculatePortfolioTargetPercentage();
              datasets.push({
                label: "Portfolio Target",
                data: [{
                  x: ninetyDayDate,
                  y: portfolioTarget,
                }],
                borderColor: "rgba(255, 193, 7, 0.8)",
                backgroundColor: "rgba(255, 193, 7, 0.8)",
                borderWidth: 3,
                pointRadius: 6,
                pointHoverRadius: 8,
                fill: false, // Don't connect points
              });
            }
          }

          // Add intrinsic value shading for single stock view
          if (this.selectedStock) {
            const stock = this.scoreData.find(s => s.stock === this.selectedStock);
            if (stock && stock.intrinsicValuePerShareBasic !== null && stock.intrinsicValuePerShareAdjusted !== null) {
              // Calculate buy price for this stock
              const marketData = this.marketData[stock.stock];
              let buyPrice = 0;
              if (marketData) {
                const scoreDateData = marketData.find((point) => {
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() === scoreDateOnly.getTime();
                });
                buyPrice = scoreDateData
                  ? this.adjustHistoricalPriceToCurrent(
                    (scoreDateData.high + scoreDateData.low) / 2,
                    stock.stock,
                    scoreDate,
                  )
                  : this.adjustHistoricalPriceToCurrent(
                    stock.target,
                    stock.stock,
                    scoreDate,
                  );
              }
              
              const adjustedBasicValue = this.adjustHistoricalPriceToCurrent(
                stock.intrinsicValuePerShareBasic,
                stock.stock,
                scoreDate,
              );
              const adjustedAdjustedValue = this.adjustHistoricalPriceToCurrent(
                stock.intrinsicValuePerShareAdjusted,
                stock.stock,
                scoreDate,
              );
              
              const basicPercentage = ((adjustedBasicValue - buyPrice) / buyPrice) * 100;
              const adjustedPercentage = ((adjustedAdjustedValue - buyPrice) / buyPrice) * 100;
              
              // Only show shading if both intrinsic values are positive
              if (basicPercentage > 0 && adjustedPercentage > 0) {
                // Determine which is higher and which is lower
                const lowerValue = Math.min(basicPercentage, adjustedPercentage);
                const higherValue = Math.max(basicPercentage, adjustedPercentage);
                
                // Create the lower boundary line with fill to the upper line
                datasets.push({
                  label: "Intrinsic Value (Lower)",
                  data: [
                    { x: scoreDate, y: lowerValue },
                    { x: ninetyDayDate, y: lowerValue }
                  ],
                  borderColor: "rgba(40, 167, 69, 0.8)",
                  backgroundColor: "rgba(40, 167, 69, 0.1)",
                  borderWidth: 2,
                  fill: '+1', // Fill to the next dataset (upper boundary)
                  pointRadius: 0,
                  showLine: true,
                  tension: 0,
                });
                
                // Create the upper boundary line
                datasets.push({
                  label: "Intrinsic Value (Upper)",
                  data: [
                    { x: scoreDate, y: higherValue },
                    { x: ninetyDayDate, y: higherValue }
                  ],
                  borderColor: "rgba(40, 167, 69, 0.8)",
                  backgroundColor: "rgba(40, 167, 69, 0.1)",
                  borderWidth: 2,
                  fill: false,
                  pointRadius: 0,
                  showLine: true,
                  tension: 0,
                });
              }
            }
          }

          // Add cost of capital line (remove dots)
          const costOfCapitalData = this.calculateCostOfCapitalData();
          if (costOfCapitalData.length > 0) {
            datasets.push({
              label: "Cost of Capital",
              data: costOfCapitalData,
              borderColor: "rgba(108, 117, 125, 0.8)",
              backgroundColor: "rgba(108, 117, 125, 0.1)",
              borderWidth: 2,
              fill: false,
              pointRadius: 0, // No points, just a line
            });
          }

          return { datasets };
        }

        calculatePortfolioData() {
          const scoreDate = this.getScoreDate(this.selectedFile);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );
          const portfolioData = [];

          // Get all unique dates from market data (include all dates, not just 90 days)
          const allDates = new Set();
          this.scoreData.forEach((stock) => {
            const marketData = this.marketData[stock.stock];
            if (marketData) {
              marketData.forEach((point) => {
                // Include all dates, not just within 90 days
                allDates.add(point.date.getTime());
              });
            }
          });

          // Add the score date to ensure we start at zero
          allDates.add(scoreDate.getTime());

          const sortedDates = Array.from(allDates).sort((a, b) =>
            a - b
          );

          // Simple debug: Check if dividend data is loaded
          console.log("Dividend data loaded:", !!this.dividendData);
          if (this.dividendData) {
            console.log(
              "Stocks with dividends:",
              Object.keys(this.dividendData),
            );
          }

          sortedDates.forEach((timestamp) => {
            const date = new Date(timestamp);
            let totalPerformance = 0;
            let validStocks = 0;

            this.scoreData.forEach((stock) => {
              const marketData = this.marketData[stock.stock];
              if (marketData) {
                const dataPoint = marketData.find(
                  (point) => point.date.getTime() === timestamp,
                );

                // Get the price on the score date as the buy price
                const scoreDateData = marketData.find((point) => {
                  // Compare dates by day only, ignoring time components
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                });
                const buyPrice = scoreDateData
                  ? this.adjustHistoricalPriceToCurrent(
                    (scoreDateData.high + scoreDateData.low) / 2,
                    stock.stock,
                    scoreDate,
                  )
                  : this.adjustHistoricalPriceToCurrent(
                    stock.target,
                    stock.stock,
                    scoreDate,
                  );

                if (dataPoint) {
                  // Use split-adjusted price for current price calculation
                  const currentPrice = this
                    .adjustHistoricalPriceToCurrent(
                      (dataPoint.high + dataPoint.low) / 2,
                      stock.stock,
                      dataPoint.date,
                    );

                  // Calculate price return
                  const priceReturn =
                    ((currentPrice - buyPrice) / buyPrice) * 100;

                  // Add dividend return up to this date (but only count dividends within 90 days)
                  const dividends = this.getDividendsWithin90Days(
                    stock.stock,
                  );
                  const dividendsUpToDate = dividends.filter((d) =>
                    d.exDivDate <= date
                  );
                  const totalDividends = dividendsUpToDate.reduce(
                    (sum, div) => sum + div.amount,
                    0,
                  );
                  const dividendReturn = (totalDividends / buyPrice) *
                    100;

                  // Total return including dividends
                  const totalReturn = priceReturn + dividendReturn;

                  totalPerformance += totalReturn;
                  validStocks++;
                } else if (timestamp === scoreDate.getTime()) {
                  // For the score date, performance is 0%
                  validStocks++;
                  // totalPerformance remains 0
                }
              }
            });

            if (validStocks > 0) {
              const portfolioPoint = {
                x: date,
                y: totalPerformance / validStocks,
              };

              // Check if this is an ex-dividend date for any stock
              const dividendsOnDate = [];
              if (this.dividendData) {
                Object.entries(this.dividendData).forEach(
                  ([stock, dividends]) => {
                    dividends.forEach((d) => {
                      // Only count dividends within 90 days
                      if (d.exDivDate <= ninetyDayDate) {
                        const dDateOnly = new Date(
                          d.exDivDate.getFullYear(),
                          d.exDivDate.getMonth(),
                          d.exDivDate.getDate(),
                        );
                        const pointDateOnly = new Date(
                          date.getFullYear(),
                          date.getMonth(),
                          date.getDate(),
                        );

                        if (
                          dDateOnly.getTime() ===
                            pointDateOnly.getTime()
                        ) {
                          dividendsOnDate.push(
                            `${stock}: $${d.amount.toFixed(2)}`,
                          );
                        }
                      }
                    });
                  },
                );
              }
              if (dividendsOnDate.length > 0) {
                portfolioPoint.dividend = dividendsOnDate.join(", ");
                console.log(
                  "Found ex-dividend date:",
                  date.toDateString(),
                  "with dividends:",
                  dividendsOnDate,
                );
              }

              portfolioData.push(portfolioPoint);
            }
          });

          console.log(
            "Portfolio data points with dividends:",
            portfolioData.filter((p) => p.dividend).length,
          );

          return portfolioData;
        }

        calculateCostOfCapitalData() {
          const scoreDate = this.getScoreDate(this.selectedFile);
          const costOfCapitalData = [];

          // Get all unique dates from market data (include all dates, not just 90 days)
          const allDates = new Set();
          this.scoreData.forEach((stock) => {
            const marketData = this.marketData[stock.stock];
            if (marketData) {
              marketData.forEach((point) => {
                // Include all dates, not just within 90 days
                allDates.add(point.date.getTime());
              });
            }
          });

          const sortedDates = Array.from(allDates).sort((a, b) =>
            a - b
          );

          sortedDates.forEach((timestamp) => {
            const date = new Date(timestamp);
            const daysSinceScore = (date - scoreDate) /
              (1000 * 60 * 60 * 24);
            const costOfCapitalReturn = (this.costOfCapital / 365) *
              daysSinceScore;

            costOfCapitalData.push({
              x: date,
              y: costOfCapitalReturn,
            });
          });

          return costOfCapitalData;
        }

        getColor(index, alpha = 1) {
          const colors = [
            `rgba(220, 53, 69, ${alpha})`, // Red
            `rgba(40, 167, 69, ${alpha})`, // Green
            `rgba(255, 193, 7, ${alpha})`, // Yellow
            `rgba(23, 162, 184, ${alpha})`, // Cyan
            `rgba(111, 66, 193, ${alpha})`, // Purple
          ];
          return colors[index % colors.length];
        }

        updateStockTable() {
          const tbody = document.getElementById("stockTableBody");
          tbody.innerHTML = "";

          // Remove any existing summary elements first
          const existingSummary = document.querySelector(
            ".portfolio-summary",
          );
          if (existingSummary) {
            existingSummary.remove();
          }

          // Determine which stocks to show
          const stocksToShow = this.selectedStock
            ? this.scoreData.filter((stock) =>
              stock.stock === this.selectedStock
            )
            : this.scoreData;

          if (this.selectedStock) {
            // Single stock view - show as card instead of table
            const stock = stocksToShow[0];
            if (stock) {
              const performance = this.calculateStockPerformance(stock);
              const judgement = this.calculateJudgement(
                stock,
                performance,
              );
              const dividends = this.getDividendsWithin90Days(
                stock.stock,
              );
              const totalDividends = dividends.reduce(
                (sum, div) => sum + div.amount,
                0,
              );

              // Calculate buy price using market data on score date
              const scoreDate = this.getScoreDate(this.selectedFile);
              const marketData = this.marketData[stock.stock];
              const scoreDateData = marketData
                ? marketData.find((point) => {
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                })
                : null;

              const buyPrice = scoreDateData
                ? this.adjustHistoricalPriceToCurrent(
                  (scoreDateData.high + scoreDateData.low) / 2,
                  stock.stock,
                  scoreDate,
                )
                : this.adjustHistoricalPriceToCurrent(
                  stock.target,
                  stock.stock,
                  scoreDate,
                ); // fallback to target if no market data
              const target = this.adjustHistoricalPriceToCurrent(
                stock.target,
                stock.stock,
                scoreDate,
              );

              // Hide the table and show card
              const tableContainer = document.querySelector(
                ".table-responsive",
              );
              tableContainer.style.display = "none";

              // Create or update stock detail card
              let stockCard = document.getElementById(
                "stockDetailCard",
              );
              if (!stockCard) {
                stockCard = document.createElement("div");
                stockCard.id = "stockDetailCard";
                stockCard.className = "card mb-4";
                tableContainer.parentNode.insertBefore(
                  stockCard,
                  tableContainer,
                );
              }

              stockCard.innerHTML = `
                <div class="card-header">
                  <h5 class="card-title mb-0">${stock.stock} - Detailed Information</h5>
                </div>
                <div class="card-body">
                  <div class="row">
                    <div class="col-md-6">
                      <h6 class="text-muted text-uppercase mb-3">Basic Information</h6>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Score:</strong></div>
                        <div class="col-6">${
                stock.score.toFixed(3)
              }</div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Buy Price:</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Buy Price - ${stock.stock}" data-field="buy-price" data-stock="${stock.stock}">$${
                buyPrice !== null ? buyPrice.toFixed(2) : "N/A"
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>90-Day Target:</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="90-Day Target - ${stock.stock}" data-field="target" data-stock="${stock.stock}">$${
                target !== null ? target.toFixed(2) : "N/A"
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Target Percentage:</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Target Percentage - ${stock.stock}" data-field="target-percentage" data-stock="${stock.stock}">${
                buyPrice > 0 && target !== null 
                  ? ((target - buyPrice) / buyPrice * 100).toFixed(1) + "%"
                  : "N/A"
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Current Price:</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Current Price - ${stock.stock}" data-field="current-price" data-stock="${stock.stock}">${
                this.getCurrentPrice(stock.stock)
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Performance:</strong></div>
                        <div class="col-6">
                          <span class="clickable-value ${
                this.getPerformanceClass(performance)
              }" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Gain/Loss - ${stock.stock}" data-field="gain-loss" data-stock="${stock.stock}">${
                performance !== null
                  ? performance.toFixed(1) + "%"
                  : "N/A"
              }</span>
                        </div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Progress vs Cost of Capital:</strong></div>
                        <div class="col-6">
                          <span class="clickable-value ${
                this.getPerformanceClass(performance)
              }" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Progress vs Cost of Capital - ${stock.stock}" data-field="progress-vs-cost" data-stock="${stock.stock}">${
                this.calculateProgressVsCostOfCapital(
                  stock,
                  performance,
                )
              }</span>
                        </div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Judgement:</strong></div>
                        <div class="col-6">
                          <span class="badge ${
                this.getJudgementClass(judgement)
              }">
                            <span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Judgement - ${stock.stock}" data-field="judgement" data-stock="${stock.stock}">${judgement}</span>
                          </span>
                        </div>
                      </div>
                    </div>
                    <div class="col-md-6">
                      <h6 class="text-muted text-uppercase mb-3">Valuation & Dividends</h6>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Intrinsic Value (Basic):</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Intrinsic Value (Basic) - ${stock.stock}" data-field="intrinsic-basic" data-stock="${stock.stock}">${
                stock.intrinsicValuePerShareBasic !== null
                  ? "$" +
                    this.adjustHistoricalPriceToCurrent(
                      stock.intrinsicValuePerShareBasic,
                      stock.stock,
                      this.getScoreDate(this.selectedFile),
                    ).toFixed(2)
                  : "N/A"
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Intrinsic Value (Adjusted):</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Intrinsic Value (Adjusted) - ${stock.stock}" data-field="intrinsic-adjusted" data-stock="${stock.stock}">${
                stock.intrinsicValuePerShareAdjusted !== null
                  ? "$" +
                    this.adjustHistoricalPriceToCurrent(
                      stock.intrinsicValuePerShareAdjusted,
                      stock.stock,
                      this.getScoreDate(this.selectedFile),
                    ).toFixed(2)
                  : "N/A"
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Ex-Dividend Date:</strong></div>
                        <div class="col-6">${
                stock.exDividendDate || "N/A"
              }</div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Average Dividend (90-day):</strong></div>
                        <div class="col-6"><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Average Dividend (90-day) - ${stock.stock}" data-field="avg-dividend" data-stock="${stock.stock}">${
                dividends.length > 0
                  ? "$" + (totalDividends / dividends.length).toFixed(4)
                  : "N/A"
              }</span></div>
                      </div>
                      <div class="row mb-2">
                        <div class="col-6"><strong>Total Dividends (90-day):</strong></div>
                        <div class="col-6">
                          <span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Total Dividends (90-day) - ${stock.stock}" data-field="total-dividend" data-stock="${stock.stock}">${
                dividends.length > 0
                  ? `$${
                    totalDividends.toFixed(2)
                  } (${dividends.length} div${
                    dividends.length > 1 ? "s" : ""
                  })`
                  : "None"
              }</span>
                        </div>
                      </div>
                    </div>
                  </div>
                  ${
                stock.notes
                  ? `
                    <div class="row mt-3">
                      <div class="col-12">
                        <h6 class="text-muted text-uppercase mb-2">Notes</h6>
                        <div class="stock-notes p-3 bg-light rounded">
                          ${stock.notes}
                        </div>
                      </div>
                    </div>
                  `
                  : ""
              }
                </div>
              `;
            }
          } else {
            // Aggregate view - show table
            const tableContainer = document.querySelector(
              ".table-responsive",
            );
            tableContainer.style.display = "block";

            // Remove stock detail card if it exists
            const stockCard = document.getElementById(
              "stockDetailCard",
            );
            if (stockCard) {
              stockCard.remove();
            }

            // Update table headers for aggregate view
            const thead = document.querySelector(
              "#stockTable thead tr",
            );
            thead.innerHTML = `
              <th>Stock</th>
              <th>Buy Price</th>
              <th>90-Day Target</th>
              <th>Current Price</th>
              <th>Gain/Loss (%)</th>
              <th>Progress vs Cost of Capital</th>
              <th>Judgement (90-day)</th>
              <th>Dividends</th>
            `;

            let totalPerformance = 0;
            let validStocks = 0;

            stocksToShow.forEach((stock) => {
              const row = document.createElement("tr");
              const scoreDate = this.getScoreDate(this.selectedFile);
              const ninetyDayDate = new Date(
                scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
              );
              const marketData = this.marketData[stock.stock];
              // Split-adjusted buy price and target
              // buy price should be the (high + low) / 2 on the score date
              const scoreDateData = marketData
                ? marketData.find((point) => {
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                })
                : null;

              const buyPrice = scoreDateData
                ? this.adjustHistoricalPriceToCurrent(
                  (scoreDateData.high + scoreDateData.low) / 2,
                  stock.stock,
                  scoreDate,
                )
                : this.adjustHistoricalPriceToCurrent(
                  stock.target,
                  stock.stock,
                  scoreDate,
                ); // fallback to target if no market data
              const target = this.adjustHistoricalPriceToCurrent(
                stock.target,
                stock.stock,
                scoreDate,
              );
              // Current price (already post-split, no adjustment needed)
              let currentPrice = null;
              if (marketData && marketData.length > 0) {
                const within90Days = marketData.filter((point) =>
                  point.date <= ninetyDayDate
                );
                if (within90Days.length > 0) {
                  const lastData =
                    within90Days[within90Days.length - 1];
                  currentPrice = (lastData.high + lastData.low) / 2; // No split adjustment needed
                }
              }
              // Gain/loss calculation (split-adjusted)
              let performance = null;
              if (buyPrice && currentPrice !== null) {
                // Add dividend return within 90 days
                const dividends = this.getDividendsWithin90Days(
                  stock.stock,
                );
                const totalDividends = dividends.reduce(
                  (sum, div) => sum + div.amount,
                  0,
                );
                const priceReturn =
                  ((currentPrice - buyPrice) / buyPrice) * 100;
                const dividendReturn = (totalDividends / buyPrice) *
                  100;
                performance = priceReturn + dividendReturn;
              }
              const judgement = this.calculateJudgement(
                stock,
                performance,
              );
              // Get dividend information (only within 90 days)
              const dividends = this.getDividendsWithin90Days(
                stock.stock,
              );
              const totalDividends = dividends.reduce(
                (sum, div) => sum + div.amount,
                0,
              );
              const dividendInfo = dividends.length > 0
                ? `$${
                  totalDividends.toFixed(2)
                } (${dividends.length} div${
                  dividends.length > 1 ? "s" : ""
                })`
                : "None";
              // Aggregate view
              row.innerHTML = `
                <td class="clickable-stock" onclick="validator.showStockDetails('${stock.stock}')">${stock.stock}</td>
                <td><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Buy Price - ${stock.stock}" data-field="buy-price" data-stock="${stock.stock}">$${
                buyPrice !== null ? buyPrice.toFixed(2) : "N/A"
              }</span></td>
                <td><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="90-Day Target - ${stock.stock}" data-field="target" data-stock="${stock.stock}">$${
                target !== null ? target.toFixed(2) : "N/A"
              }</span></td>
                <td><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Current Price - ${stock.stock}" data-field="current-price" data-stock="${stock.stock}">${
                currentPrice !== null
                  ? "$" + currentPrice.toFixed(2)
                  : "N/A"
              }</span></td>
                <td><span class="clickable-value ${
                this.getPerformanceClass(performance)
              }" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Gain/Loss - ${stock.stock}" data-field="gain-loss" data-stock="${stock.stock}">${
                performance !== null
                  ? performance.toFixed(1) + "%"
                  : "N/A"
              }</span></td>
                <td><span class="clickable-value ${
                this.getPerformanceClass(performance)
              }" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Progress vs Cost of Capital - ${stock.stock}" data-field="progress-vs-cost" data-stock="${stock.stock}">${
                this.calculateProgressVsCostOfCapital(
                  stock,
                  performance,
                )
              }</span></td>
                <td><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Judgement - ${stock.stock}" data-field="judgement" data-stock="${stock.stock}"><span class="badge ${
                this.getJudgementClass(judgement)
              }">${judgement}</span></span></td>
                <td><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Dividends - ${stock.stock}" data-field="dividend-info" data-stock="${stock.stock}">${dividendInfo}</span></td>
              `;
              // Add highlighting for selected stock in aggregate view
              if (this.selectedStock === stock.stock) {
                row.classList.add("table-primary");
              }
              tbody.appendChild(row);
            });

            // Add totals row for aggregate view
            const scoreFile = this.selectedFile;
            const scoreDate = this.getScoreDate(scoreFile);
            const daysElapsed = this.getDaysElapsed(scoreDate);
            const portfolioPerformance90Day = this
              .calculatePortfolioPerformance90Day();
            const portfolioTarget = this
              .calculatePortfolioTargetPercentage();

            // Calculate actual days elapsed (max 90)
            const actualDaysElapsed = Math.min(daysElapsed, 90);

            const totalsRow = document.createElement("tr");
            totalsRow.classList.add("table-info", "fw-bold");
            totalsRow.innerHTML = `
              <td>Days Elapsed: ${actualDaysElapsed}</td>
              <td>-</td>
              <td><span class="clickable-value" data-bs-toggle="popover" data-bs-trigger="click" data-bs-content="" data-bs-title="Portfolio Target" data-field="portfolio-target" data-stock="">${
              portfolioTarget.toFixed(1)
            }%</span></td>
              <td>-</td>
              <td class="${
              this.getPerformanceClass(portfolioPerformance90Day)
            }">${portfolioPerformance90Day.toFixed(1)}%</td>
              <td>-</td>
              <td>-</td>
              <td>-</td>
            `;

            tbody.appendChild(totalsRow);
          }

          // Dispose of existing popovers
          const existingPopovers = document.querySelectorAll(
            '.clickable-value[data-bs-toggle="popover"]',
          );
          existingPopovers.forEach((element) => {
            const popover = bootstrap.Popover.getInstance(element);
            if (popover) {
              popover.dispose();
            }
          });

          // Loop through all .clickable-value elements
          const clickableValues = document.querySelectorAll(
            ".clickable-value",
          );
          clickableValues.forEach((value) => {
            const field = value.getAttribute("data-field");
            const stock = value.getAttribute("data-stock");

            // Generate the popover content using the actual values for that stock/field
            let working;
            if (field === "portfolio-target") {
              // Special handling for portfolio target - no specific stock
              working = this.getWorking(field, "", this.scoreData);
            } else {
              working = this.getWorking(field, stock, this.scoreData);
            }

            // Set the data-bs-content attribute
            value.setAttribute("data-bs-content", working);

            // Initialize the Bootstrap popover
            new bootstrap.Popover(value, {
              trigger: "manual",
              html: false,
              container: "body",
            });
          });

          // Add document click handler to close popovers when clicking outside
          // Temporarily disabled to fix popover issues
          /*
          document.addEventListener('click', (event) => {
            const clickableValues = document.querySelectorAll('.clickable-value');
            let clickedOnPopover = false;

            clickableValues.forEach(element => {
              if (element.contains(event.target) || event.target.closest('.popover')) {
                clickedOnPopover = true;
              }
            });

            if (!clickedOnPopover) {
              // Close all open popovers
              clickableValues.forEach(element => {
                const popover = bootstrap.Popover.getInstance(element);
                if (popover && popover._isShown()) {
                  popover.hide();
                }
              });
            }
          });
          */
        }

        getDividendsWithin90Days(stockSymbol) {
          const dividends = this.dividendData?.[stockSymbol] || [];
          const scoreDate = this.getScoreDate(this.selectedFile);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );

          return dividends.filter((dividend) =>
            dividend.exDivDate <= ninetyDayDate
          );
        }

        getCurrentPrice(stockSymbol) {
          const marketData = this.marketData[stockSymbol];
          if (!marketData || marketData.length === 0) return "N/A";

          const scoreDate = this.getScoreDate(this.selectedFile);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );

          // Find the last price within 90 days
          const within90Days = marketData.filter((point) =>
            point.date <= ninetyDayDate
          );
          if (within90Days.length === 0) return "N/A";

          const lastData = within90Days[within90Days.length - 1];
          const currentPrice = (lastData.high + lastData.low) / 2; // Already post-split
          return "$" + currentPrice.toFixed(2);
        }

        calculateProgressVsCostOfCapital(stock, performance) {
          if (performance === null) return "N/A";

          // Use 90 days for cost of capital calculation since all performance is 90-day based
          const costOfCapitalReturn = (this.costOfCapital / 365) * 90;

          const excessReturn = performance - costOfCapitalReturn;
          return excessReturn.toFixed(1) + "%";
        }

        calculateJudgement(stock, performance) {
          if (performance === null) return "Pending";

          const targetReturn = 20; // 20% target
          const threshold = targetReturn * 0.8; // 80% of target

          if (performance >= threshold) {
            return "Hit Target";
          } else if (performance > 0) {
            return "Partial Success";
          } else {
            return "Missed Target";
          }
        }

        getPerformanceClass(performance) {
          if (performance === null) return "performance-neutral";
          return performance >= 0
            ? "performance-positive"
            : "performance-negative";
        }

        getJudgementClass(judgement) {
          switch (judgement) {
            case "Hit Target":
              return "judgement-hit";
            case "Partial Success":
              return "judgement-partial";
            case "Missed Target":
              return "judgement-miss";
            default:
              return "bg-secondary";
          }
        }

        showStockDetails(stockSymbol) {
          this.selectedStock = stockSymbol;
          this.updateDisplay();

          // Show the back button
          document.getElementById("backToAggregate").style.display =
            "block";
        }

        showLoading() {
          document.getElementById("loading").style.display = "block";
          document.getElementById("summary").style.display = "none";
          document.getElementById("error").style.display = "none";
          document.getElementById("noData").style.display = "none";
        }

        showError(message) {
          document.getElementById("loading").style.display = "none";
          document.getElementById("summary").style.display = "none";
          document.getElementById("noData").style.display = "none";
          document.getElementById("error").style.display = "block";
          document.getElementById("error").textContent = message;
        }

        showNoData() {
          document.getElementById("loading").style.display = "none";
          document.getElementById("summary").style.display = "none";
          document.getElementById("error").style.display = "none";
          document.getElementById("noData").style.display = "block";
        }

        hideMessages() {
          document.getElementById("loading").style.display = "none";
          document.getElementById("error").style.display = "none";
          document.getElementById("noData").style.display = "none";
          document.getElementById("summary").style.display = "block";
        }

        getScoreDate(scoreFile) {
          // Extract date from filename like "2025/June/20.tsv"
          const match = scoreFile.match(/(\d{4})\/(\w+)\/(\d+)\.tsv/);
          if (match) {
            const [, year, month, day] = match;
            const monthIndex = new Date(`${month} 1, ${year}`)
              .getMonth();
            return new Date(parseInt(year), monthIndex, parseInt(day));
          }
          return new Date();
        }

        getDaysElapsed(scoreDate) {
          const today = new Date();
          const diffTime = Math.abs(today - scoreDate);
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
          return diffDays;
        }

        calculateStockPerformance(stock) {
          const marketData = this.marketData[stock.stock];
          if (!marketData || marketData.length === 0) return null;

          const scoreDate = this.getScoreDate(this.selectedFile);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );

          // Find the last price within 90 days
          const within90Days = marketData.filter((point) =>
            point.date <= ninetyDayDate
          );
          if (within90Days.length === 0) return null;

          const lastData = within90Days[within90Days.length - 1];
          const currentPrice = (lastData.high + lastData.low) / 2; // Already post-split

          // Get the price on the score date as the buy price (adjusted to current price level)
          const scoreDateData = marketData.find((point) => {
            // Compare dates by day only, ignoring time components
            const pointDate = new Date(
              point.date.getFullYear(),
              point.date.getMonth(),
              point.date.getDate(),
            );
            const scoreDateOnly = new Date(
              scoreDate.getFullYear(),
              scoreDate.getMonth(),
              scoreDate.getDate(),
            );
            return pointDate.getTime() === scoreDateOnly.getTime();
          });
          const buyPrice = scoreDateData
            ? this.adjustHistoricalPriceToCurrent(
              (scoreDateData.high + scoreDateData.low) / 2,
              stock.stock,
              scoreDate,
            )
            : this.adjustHistoricalPriceToCurrent(
              stock.target,
              stock.stock,
              scoreDate,
            );

          // Calculate price return
          const priceReturn = ((currentPrice - buyPrice) / buyPrice) *
            100;

          // Add dividend return within 90 days
          const dividends = this.getDividendsWithin90Days(stock.stock);
          const totalDividends = dividends.reduce(
            (sum, div) => sum + div.amount,
            0,
          );
          const dividendReturn = (totalDividends / buyPrice) * 100;

          // Total return including dividends
          return priceReturn + dividendReturn;
        }

        calculatePortfolioTargetPercentage() {
          // Calculate portfolio target based on the actual targets of all stocks
          let totalTarget = 0;
          let validStocks = 0;

          this.scoreData.forEach((stock) => {
            if (stock.target !== null && !isNaN(stock.target)) {
              // Calculate target percentage based on actual target price vs buy price
              const scoreDate = this.getScoreDate(this.selectedFile);
              const buyPrice = this.getBuyPrice(stock.stock, scoreDate);
              if (buyPrice > 0) {
                const targetPercentage =
                  ((stock.target - buyPrice) / buyPrice) * 100;
                totalTarget += targetPercentage;
                validStocks++;
              }
            }
          });

          return validStocks > 0 ? totalTarget / validStocks : 20.0;
        }

        calculatePortfolioPerformance90Day() {
          const scoreDate = this.getScoreDate(this.selectedFile);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );

          let totalPerformance = 0;
          let validStocks = 0;

          this.scoreData.forEach((stock) => {
            const marketData = this.marketData[stock.stock];
            if (marketData) {
              // Find the price at 90 days (or closest available date)
              let ninetyDayData = null;

              // First try to find exact 90-day date
              ninetyDayData = marketData.find((point) => {
                const pointDate = new Date(
                  point.date.getFullYear(),
                  point.date.getMonth(),
                  point.date.getDate(),
                );
                const targetDate = new Date(
                  ninetyDayDate.getFullYear(),
                  ninetyDayDate.getMonth(),
                  ninetyDayDate.getDate(),
                );
                return pointDate.getTime() === targetDate.getTime();
              });

              // If not found, find the closest date within 90 days
              if (!ninetyDayData) {
                const within90Days = marketData.filter((point) =>
                  point.date <= ninetyDayDate
                );
                if (within90Days.length > 0) {
                  // Get the latest data point within 90 days
                  ninetyDayData = within90Days[within90Days.length - 1];
                }
              }

              if (ninetyDayData) {
                // Get the price on the score date as the buy price
                const scoreDateData = marketData.find((point) => {
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                });

                const buyPrice = scoreDateData
                  ? this.adjustHistoricalPriceToCurrent(
                    (scoreDateData.high + scoreDateData.low) / 2,
                    stock.stock,
                    scoreDate,
                  )
                  : this.adjustHistoricalPriceToCurrent(
                    stock.target,
                    stock.stock,
                    scoreDate,
                  );

                const currentPrice =
                  (ninetyDayData.high + ninetyDayData.low) / 2; // Already post-split

                // Add dividend income within 90 days
                const dividends = this.getDividendsWithin90Days(
                  stock.stock,
                );
                const totalDividends = dividends.reduce(
                  (sum, div) => sum + div.amount,
                  0,
                );

                // Calculate total return including dividends
                const priceReturn =
                  ((currentPrice - buyPrice) / buyPrice) * 100;
                const dividendReturn = (totalDividends / buyPrice) *
                  100;
                const totalReturn = priceReturn + dividendReturn;

                totalPerformance += totalReturn;
                validStocks++;
              }
            }
          });

          return validStocks > 0 ? totalPerformance / validStocks : 0;
        }

        getWorking(field, stockSymbol, scoreData) {
          // Special handling for portfolio target - no specific stock needed
          if (field === "portfolio-target") {
            const portfolioTargetValue = this
              .calculatePortfolioTargetPercentage();
            const scoreDate = this.getScoreDate(this.selectedFile);

            // Calculate individual stock targets for display
            let targetDetails = [];
            let totalTarget = 0;
            let validStocks = 0;

            this.scoreData.forEach((stock) => {
              if (stock.target !== null && !isNaN(stock.target)) {
                const buyPrice = this.getBuyPrice(
                  stock.stock,
                  scoreDate,
                );
                if (buyPrice > 0) {
                  const targetPercentage =
                    ((stock.target - buyPrice) / buyPrice) * 100;
                  targetDetails.push(
                    `${stock.stock}: ${targetPercentage.toFixed(1)}%`,
                  );
                  totalTarget += targetPercentage;
                  validStocks++;
                }
              }
            });

            return `Portfolio Target working:\n= Average target of all stocks in portfolio\n= Individual targets:\n  ${
              targetDetails.join("\n  ")
            }\n= Total: ${
              totalTarget.toFixed(1)
            }% / ${validStocks} stocks\n= Portfolio target: ${
              portfolioTargetValue.toFixed(1)
            }%`;
          }

          const stock = scoreData.find((s) => s.stock === stockSymbol);
          if (!stock) return "Stock not found";

          const scoreDate = this.getScoreDate(this.selectedFile);
          const currentDate = new Date();
          const header =
            `Stock: ${stockSymbol} | Field: ${field} | Score Date: ${
              scoreDate.toISOString().split("T")[0]
            } | Current Date: ${
              currentDate.toISOString().split("T")[0]
            }\n\n`;

          switch (field) {
            case "buy-price":
              const buyPriceMarketData = this.marketData[stockSymbol];
              const buyPriceScoreDateData = buyPriceMarketData
                ? buyPriceMarketData.find((point) => {
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                })
                : null;

              const buyPriceOriginalPrice = buyPriceScoreDateData
                ? (buyPriceScoreDateData.high +
                  buyPriceScoreDateData.low) / 2
                : stock.target; // fallback to target if no market data

              const buyPriceSplitAdjustment = this
                .getHistoricalToCurrentSplitAdjustment(
                  stockSymbol,
                  scoreDate,
                );
              const adjustedBuyPrice = this
                .adjustHistoricalPriceToCurrent(
                  buyPriceOriginalPrice,
                  stockSymbol,
                  scoreDate,
                );

              if (buyPriceSplitAdjustment > 1.0) {
                return header +
                  `Buy Price working:\n= Market price on score date (adjusted for ${buyPriceSplitAdjustment}:1 split)\n= Original: $${
                    buyPriceOriginalPrice.toFixed(2)
                  }\n= Split adjustment: √∑ ${buyPriceSplitAdjustment}\n= Adjusted: $${
                    adjustedBuyPrice.toFixed(2)
                  }`;
              } else {
                return header +
                  `Buy Price working:\n= Market price on score date\n= $${
                    adjustedBuyPrice.toFixed(2)
                  }`;
              }
            case "target":
              const targetSplitAdjustment = this
                .getHistoricalToCurrentSplitAdjustment(
                  stockSymbol,
                  scoreDate,
                );
              const adjustedTarget = this
                .adjustHistoricalPriceToCurrent(
                  stock.target,
                  stockSymbol,
                  scoreDate,
                );
              if (targetSplitAdjustment > 1.0) {
                return header +
                  `90-Day Target working:\n= Target price from score file (adjusted for ${targetSplitAdjustment}:1 split)\n= Original: $${
                    stock.target.toFixed(2)
                  }\n= Split adjustment: √∑ ${targetSplitAdjustment}\n= Adjusted: $${
                    adjustedTarget.toFixed(2)
                  }`;
              } else {
                return header +
                  `90-Day Target working:\n= Target price from score file\n= $${
                    stock.target.toFixed(2)
                  }\n= $${adjustedTarget.toFixed(2)}`;
              }
            case "target-percentage":
              const targetPercentageBuyPrice = this.getBuyPrice(stockSymbol, scoreDate);
              const targetPercentageTarget = this.adjustHistoricalPriceToCurrent(
                stock.target,
                stockSymbol,
                scoreDate,
              );
              if (targetPercentageBuyPrice > 0 && targetPercentageTarget !== null) {
                const targetPercentage = ((targetPercentageTarget - targetPercentageBuyPrice) / targetPercentageBuyPrice) * 100;
                return header +
                  `Target Percentage working:\n= ((Target Price - Buy Price) / Buy Price) √ó 100\n= (($${targetPercentageTarget.toFixed(2)} - $${targetPercentageBuyPrice.toFixed(2)}) / $${targetPercentageBuyPrice.toFixed(2)}) √ó 100\n= $${(targetPercentageTarget - targetPercentageBuyPrice).toFixed(2)} / $${targetPercentageBuyPrice.toFixed(2)} √ó 100\n= ${targetPercentage.toFixed(1)}%`;
              } else {
                return header +
                  `Target Percentage working:\n= ((Target Price - Buy Price) / Buy Price) √ó 100\n= Insufficient data to calculate`;
              }
            case "current-price":
              const marketData = this.marketData[stockSymbol];
              if (!marketData || marketData.length === 0) {
                return header +
                  "Current Price working:\nNo market data available";
              }
              const lastData = marketData[marketData.length - 1];
              const currentPrice = (lastData.high + lastData.low) / 2; // Already post-split
              const currentSplitAdjustment = this
                .getHistoricalToCurrentSplitAdjustment(
                  stockSymbol,
                  lastData.date,
                );
              if (currentSplitAdjustment > 1.0) {
                return header +
                  `Current Price working:\n= (High + Low) / 2 from latest market data (post-split)\n= ($${
                    lastData.high.toFixed(2)
                  } + $${lastData.low.toFixed(2)}) / 2\n= $${
                    currentPrice.toFixed(2)
                  } (already post-split, no adjustment needed)`;
              } else {
                return header +
                  `Current Price working:\n= (High + Low) / 2 from latest market data\n= ($${
                    lastData.high.toFixed(2)
                  } + $${lastData.low.toFixed(2)}) / 2\n= $${
                    currentPrice.toFixed(2)
                  }`;
              }
            case "gain-loss":
              const performance = this.calculateStockPerformance(stock);
              if (performance === null) {
                return header +
                  "Gain/Loss working:\nNo market data available";
              }
              const gainLossMarketData = this.marketData[stockSymbol];
              const ninetyDayDate = new Date(
                scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
              );
              const within90Days = gainLossMarketData.filter((point) =>
                point.date <= ninetyDayDate
              );
              const gainLossLastData =
                within90Days[within90Days.length - 1];
              const gainLossCurrentPrice =
                (gainLossLastData.high + gainLossLastData.low) / 2; // Already post-split
              const scoreDateData = gainLossMarketData.find((point) => {
                const pointDate = new Date(
                  point.date.getFullYear(),
                  point.date.getMonth(),
                  point.date.getDate(),
                );
                const scoreDateOnly = new Date(
                  scoreDate.getFullYear(),
                  scoreDate.getMonth(),
                  scoreDate.getDate(),
                );
                return pointDate.getTime() === scoreDateOnly.getTime();
              });
              const buyPrice = scoreDateData
                ? this.adjustHistoricalPriceToCurrent(
                  (scoreDateData.high + scoreDateData.low) / 2,
                  stockSymbol,
                  scoreDate,
                )
                : this.adjustHistoricalPriceToCurrent(
                  stock.target,
                  stockSymbol,
                  scoreDate,
                );
              const dividends = this.getDividendsWithin90Days(
                stockSymbol,
              );
              const totalDividends = dividends.reduce(
                (sum, div) => sum + div.amount,
                0,
              );

              // Get split adjustments
              const gainLossBuyPriceSplitAdjustment = this
                .getHistoricalToCurrentSplitAdjustment(
                  stockSymbol,
                  scoreDate,
                );

              if (gainLossBuyPriceSplitAdjustment > 1.0) {
                const originalBuyPrice = scoreDateData
                  ? (scoreDateData.high + scoreDateData.low) / 2
                  : stock.target;
                return header +
                  `Gain/Loss (%) working:\n= ((Current Price + Total Dividends - Buy Price) / Buy Price) √ó 100\n= (($${
                    gainLossCurrentPrice.toFixed(2)
                  } + $${totalDividends.toFixed(2)} - $${
                    buyPrice.toFixed(2)
                  }) / $${buyPrice.toFixed(2)}) √ó 100\n= ($${
                    (gainLossCurrentPrice + totalDividends).toFixed(2)
                  } - $${buyPrice.toFixed(2)}) / $${
                    buyPrice.toFixed(2)
                  } √ó 100\n= $${
                    (gainLossCurrentPrice + totalDividends - buyPrice)
                      .toFixed(2)
                  } / $${buyPrice.toFixed(2)} √ó 100\n= ${
                    ((gainLossCurrentPrice + totalDividends -
                      buyPrice) / buyPrice * 100).toFixed(1)
                  }%\n\nSplit Adjustments:\n- Buy Price: $${
                    originalBuyPrice.toFixed(2)
                  } √∑ ${gainLossBuyPriceSplitAdjustment} = $${
                    buyPrice.toFixed(2)
                  } (adjusted to current price level)\n- Current Price: $${
                    gainLossCurrentPrice.toFixed(2)
                  } (already post-split, no adjustment needed)`;
              } else {
                return header +
                  `Gain/Loss (%) working:\n= ((Current Price + Total Dividends - Buy Price) / Buy Price) √ó 100\n= (($${
                    gainLossCurrentPrice.toFixed(2)
                  } + $${totalDividends.toFixed(2)} - $${
                    buyPrice.toFixed(2)
                  }) / $${buyPrice.toFixed(2)}) √ó 100\n= ($${
                    (gainLossCurrentPrice + totalDividends).toFixed(2)
                  } - $${buyPrice.toFixed(2)}) / $${
                    buyPrice.toFixed(2)
                  } √ó 100\n= $${
                    (gainLossCurrentPrice + totalDividends - buyPrice)
                      .toFixed(2)
                  } / $${buyPrice.toFixed(2)} √ó 100\n= ${
                    ((gainLossCurrentPrice + totalDividends -
                      buyPrice) / buyPrice * 100).toFixed(1)
                  }%`;
              }
            case "progress-vs-cost":
              const progressPerformance = this
                .calculateStockPerformance(stock);
              if (progressPerformance === null) {
                return "Progress vs Cost of Capital working:\nNo market data available";
              }
              const daysElapsed = this.getDaysElapsed(
                this.getScoreDate(this.selectedFile),
              );
              const costOfCapitalReturn = (this.costOfCapital / 365) *
                daysElapsed;
              return header +
                `Progress vs Cost of Capital working:\n= Stock Performance - Cost of Capital Return\n= ${
                  progressPerformance.toFixed(1)
                }% - ${costOfCapitalReturn.toFixed(1)}%\n= ${
                  (progressPerformance - costOfCapitalReturn).toFixed(1)
                }%`;
            case "judgement":
              const judgementPerformance = this
                .calculateStockPerformance(stock);
              const judgement = this.calculateJudgement(
                stock,
                judgementPerformance,
              );
              return header +
                `Judgement (90-day) working:\n= Based on performance vs 20% target\n= Performance: ${
                  judgementPerformance !== null
                    ? judgementPerformance.toFixed(1) + "%"
                    : "N/A"
                }\n= Target: 20%\n= Judgement: ${judgement}`;
            case "intrinsic-basic":
              if (stock.intrinsicValuePerShareBasic === null) {
                return "Intrinsic Value (Basic) working:\nNo data available";
              }
              const adjustedBasicValue = this
                .adjustHistoricalPriceToCurrent(
                  stock.intrinsicValuePerShareBasic,
                  stock.stock,
                  this.getScoreDate(this.selectedFile),
                );
              return header +
                `Intrinsic Value (Basic) working:\n= Value from score file (adjusted for splits)\n= Original: $${
                  stock.intrinsicValuePerShareBasic.toFixed(2)
                }\n= Split adjustment: √∑ ${
                  this.getHistoricalToCurrentSplitAdjustment(
                    stock.stock,
                    this.getScoreDate(this.selectedFile),
                  ).toFixed(1)
                }\n= Adjusted: $${adjustedBasicValue.toFixed(2)}`;
            case "intrinsic-adjusted":
              if (stock.intrinsicValuePerShareAdjusted === null) {
                return "Intrinsic Value (Adjusted) working:\nNo data available";
              }
              const adjustedAdjustedValue = this
                .adjustHistoricalPriceToCurrent(
                  stock.intrinsicValuePerShareAdjusted,
                  stock.stock,
                  this.getScoreDate(this.selectedFile),
                );
              return header +
                `Intrinsic Value (Adjusted) working:\n= Adjusted value from score file (adjusted for splits)\n= Original: $${
                  stock.intrinsicValuePerShareAdjusted.toFixed(2)
                }\n= Split adjustment: √∑ ${
                  this.getHistoricalToCurrentSplitAdjustment(
                    stock.stock,
                    this.getScoreDate(this.selectedFile),
                  ).toFixed(1)
                }\n= Adjusted: $${adjustedAdjustedValue.toFixed(2)}`;
            case "avg-dividend":
              const avgDividends = this.getDividendsWithin90Days(
                stockSymbol,
              );
              if (avgDividends.length === 0) {
                return "Average Dividend (90-day) working:\nNo dividends in 90-day period";
              }
              const avgTotalDividends = avgDividends.reduce(
                (sum, div) => sum + div.amount,
                0,
              );
              const avgDividend = avgTotalDividends /
                avgDividends.length;
              return header +
                `Average Dividend (90-day) working:\n= Total Dividends / Number of Dividends\n= $${
                  avgTotalDividends.toFixed(2)
                } / ${avgDividends.length}\n= $${
                  avgDividend.toFixed(4)
                }`;
            case "total-dividend":
              const totalDivDividends = this.getDividendsWithin90Days(
                stockSymbol,
              );
              if (totalDivDividends.length === 0) {
                return "Total Dividends (90-day) working:\nNo dividends in 90-day period";
              }
              const totalDivAmount = totalDivDividends.reduce(
                (sum, div) => sum + div.amount,
                0,
              );
              return header +
                `Total Dividends (90-day) working:\n= Sum of all dividends within 90 days\n= ${
                  totalDivDividends.map((d) =>
                    `$${d.amount.toFixed(2)}`
                  ).join(" + ")
                }\n= $${
                  totalDivAmount.toFixed(2)
                } (${totalDivDividends.length} dividend${
                  totalDivDividends.length > 1 ? "s" : ""
                })`;
            case "dividend-info":
              const divInfoDividends = this.getDividendsWithin90Days(
                stockSymbol,
              );
              if (divInfoDividends.length === 0) {
                return "Dividend Info working:\nNo dividends in 90-day period";
              }
              const divInfoTotal = divInfoDividends.reduce(
                (sum, div) => sum + div.amount,
                0,
              );
              return header +
                `Dividend Info working:\n= Total dividends within 90 days\n= $${
                  divInfoTotal.toFixed(2)
                } (${divInfoDividends.length} dividend${
                  divInfoDividends.length > 1 ? "s" : ""
                })`;
            default:
              return "Calculation working not implemented for this field";
          }
        }

        getHistoricalToCurrentSplitAdjustment(
          stockSymbol,
          historicalDate,
        ) {
          const marketData = this.marketData[stockSymbol];
          if (!marketData) return 1.0;

          // Debug for NASDAQ:IBKR
          if (stockSymbol === "NASDAQ:IBKR") {
            console.log(
              "getHistoricalToCurrentSplitAdjustment DEBUG:",
              {
                stockSymbol,
                historicalDate:
                  historicalDate.toISOString().split("T")[0],
                marketDataLength: marketData.length,
                splits: marketData.filter((p) =>
                  p.splitCoefficient > 1.0
                ).map((p) => ({
                  date: p.date.toISOString().split("T")[0],
                  splitCoefficient: p.splitCoefficient,
                })),
              },
            );
          }

          // Find all splits that occurred after the historical date
          let cumulativeSplit = 1.0;
          for (const point of marketData) {
            if (
              point.date > historicalDate &&
              point.splitCoefficient > 1.0
            ) {
              cumulativeSplit *= point.splitCoefficient;
            }
          }

          // Debug for NASDAQ:IBKR
          if (stockSymbol === "NASDAQ:IBKR") {
            console.log(
              "getHistoricalToCurrentSplitAdjustment RESULT:",
              {
                stockSymbol,
                cumulativeSplit,
              },
            );
          }

          return cumulativeSplit;
        }

        adjustHistoricalPriceToCurrent(
          price,
          stockSymbol,
          historicalDate,
        ) {
          const splitAdjustment = this
            .getHistoricalToCurrentSplitAdjustment(
              stockSymbol,
              historicalDate,
            );
          const result = price / splitAdjustment;

          // Debug for NASDAQ:IBKR
          if (stockSymbol === "NASDAQ:IBKR") {
            console.log("adjustHistoricalPriceToCurrent DEBUG:", {
              price,
              stockSymbol,
              historicalDate:
                historicalDate.toISOString().split("T")[0],
              splitAdjustment,
              result,
            });
          }

          return result;
        }

        getBuyPrice(stockSymbol, scoreDate) {
          const marketData = this.marketData[stockSymbol];
          if (!marketData) return 0;

          // Get the price on the score date as the buy price
          const scoreDateData = marketData.find((point) => {
            const pointDate = new Date(
              point.date.getFullYear(),
              point.date.getMonth(),
              point.date.getDate(),
            );
            const scoreDateOnly = new Date(
              scoreDate.getFullYear(),
              scoreDate.getMonth(),
              scoreDate.getDate(),
            );
            return pointDate.getTime() === scoreDateOnly.getTime();
          });

          if (scoreDateData) {
            return this.adjustHistoricalPriceToCurrent(
              (scoreDateData.high + scoreDateData.low) / 2,
              stockSymbol,
              scoreDate,
            );
          }

          // Fallback to target price if no market data
          const stock = this.scoreData.find((s) =>
            s.stock === stockSymbol
          );
          if (stock && stock.target) {
            return this.adjustHistoricalPriceToCurrent(
              stock.target,
              stockSymbol,
              scoreDate,
            );
          }

          return 0;
        }
      }

      // Initialize the validator
      const validator = new GRQValidator();

      // Add document click handler to close popovers when clicking outside
      document.addEventListener("click", (event) => {
        // Check if the click was on a popover trigger or inside a popover
        const isPopoverTrigger = event.target.closest(
          ".clickable-value",
        );
        const isInsidePopover = event.target.closest(".popover");

        if (!isPopoverTrigger && !isInsidePopover) {
          // Close all open popovers
          const clickableValues = document.querySelectorAll(
            ".clickable-value",
          );
          clickableValues.forEach((element) => {
            const popover = bootstrap.Popover.getInstance(element);
            if (popover && element.hasAttribute("aria-describedby")) {
              popover.hide();
            }
          });
        }
      });
    </script>
  </body>
</html>
