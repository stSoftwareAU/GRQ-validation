<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRQ Stock Prediction Validation</title>

    <!-- Bootstrap 5 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    >

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>

    <!-- Custom styles -->
    <link rel="stylesheet" href="styles.css">
  </head>
  <body class="bg-light">
    <div class="container-fluid">
      <div class="row">
        <div class="col-12">
          <div class="card shadow-sm border-0">
            <div class="card-header header-gradient text-white text-center py-4">
              <h1 class="display-4 mb-2">GRQ Validation Dashboard</h1>
              <p class="lead mb-0">
                Validating AI predictions against 90-day targets and 10% annual
                cost of capital
              </p>
            </div>

            <div class="card-body p-4">
              <!-- Controls -->
              <div class="row mb-4">
                <div class="col-md-6 col-lg-4">
                  <div class="mb-3">
                    <label for="scoreFileSelect" class="form-label fw-bold"
                    >Score File:</label>
                    <select id="scoreFileSelect" class="form-select">
                      <option value="">Select a score file...</option>
                    </select>
                  </div>
                </div>
              </div>

              <!-- Loading and Error Messages -->
              <div id="loading" class="loading text-center py-5">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3">Loading data...</p>
              </div>

              <div id="error" class="alert alert-danger" style="display: none">
              </div>
              <div id="noData" class="alert alert-info" style="display: none">
                No market data available yet for this score file. Data will
                appear as it becomes available.
              </div>

              <!-- Main Content -->
              <div id="summary" style="display: none">
                <!-- Summary Stats -->
                <div class="row mb-4">
                  <div class="col-md-4 mb-3">
                    <div class="card stat-card h-100">
                      <div class="card-body text-center">
                        <h6 class="card-title text-muted text-uppercase">
                          Days Elapsed
                        </h6>
                        <div class="value display-6" id="daysElapsed">-</div>
                      </div>
                    </div>
                  </div>
                  <div class="col-md-4 mb-3">
                    <div class="card stat-card h-100">
                      <div class="card-body text-center">
                        <h6 class="card-title text-muted text-uppercase">
                          Stocks Tracked
                        </h6>
                        <div class="value display-6" id="stocksTracked">-</div>
                      </div>
                    </div>
                  </div>
                  <div class="col-md-4 mb-3">
                    <div class="card stat-card h-100">
                      <div class="card-body text-center">
                        <h6 class="card-title text-muted text-uppercase">
                          Average Performance
                        </h6>
                        <div class="value display-6" id="avgPerformance">-</div>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Chart -->
                <div class="row mb-4">
                  <div class="col-12">
                    <div class="d-flex justify-content-between align-items-center">
                      <h2 class="mb-0">Performance Chart</h2>
                      <button
                        id="backToAggregate"
                        class="btn btn-outline-primary"
                        style="display: none"
                      >
                        ‚Üê Back to Portfolio View
                      </button>
                    </div>
                  </div>
                </div>
                <div class="card mb-4">
                  <div class="card-body">
                    <div class="chart-container">
                      <canvas id="performanceChart"></canvas>
                    </div>
                  </div>
                </div>

                <!-- Stock Table -->
                <div class="card">
                  <div class="card-header">
                    <h5 class="card-title mb-0">
                      Individual Stock Performance
                    </h5>
                  </div>
                  <div class="card-body p-0">
                    <div class="table-responsive">
                      <table
                        class="table table-hover stock-table mb-0"
                        id="stockTable"
                      >
                        <thead>
                          <tr>
                            <th>Stock</th>
                            <th>Buy Price</th>
                            <th>90-Day Target</th>
                            <th>Current Price</th>
                            <th>Gain/Loss (%)</th>
                            <th>Progress vs Cost of Capital</th>
                            <th>Judgement (90-day)</th>
                            <th>Dividends</th>
                          </tr>
                        </thead>
                        <tbody id="stockTableBody"></tbody>
                      </table>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      class GRQValidator {
        constructor() {
          this.scoreData = null;
          this.marketData = null;
          this.dividendData = null;
          this.selectedFile = null;
          this.filteredStocks = [];
          this.selectedStock = null; // Track selected stock for single view
          this.chart = null;
          this.costOfCapital = 10; // 10% annual cost of capital

          this.initializeEventListeners();
          this.loadIndex();
        }

        initializeEventListeners() {
          document
            .getElementById("scoreFileSelect")
            .addEventListener("change", (e) => {
              this.selectedFile = e.target.value;
              this.selectedStock = null; // Reset to aggregate view
              if (this.selectedFile) {
                this.loadScoreFile();
              }
            });

          // Remove stock filter event listener - no longer needed

          // Add back to aggregate view button
          document.getElementById("backToAggregate").addEventListener(
            "click",
            () => {
              this.selectedStock = null;
              this.updateDisplay();
            },
          );
        }

        async loadIndex() {
          try {
            // Add cache-busting parameter to force fresh fetch
            const timestamp = new Date().getTime();
            const response = await fetch(
              `scores/index.json?t=${timestamp}`,
            );
            const indexData = await response.json();

            const select = document.getElementById("scoreFileSelect");
            select.innerHTML =
              '<option value="">Select a score file...</option>';

            indexData.scores.forEach((score) => {
              const option = document.createElement("option");
              option.value = score.file;
              option.textContent =
                `${score.date} (${score.month} ${score.day})`;
              select.appendChild(option);
            });

            if (indexData.scores.length > 0) {
              this.selectedFile = indexData.scores[0].file;
              select.value = this.selectedFile;
              await this.loadScoreFile();
            }
          } catch (error) {
            this.showError(
              "Failed to load score files: " + error.message,
            );
          }
        }

        async loadScoreFile() {
          this.showLoading();

          try {
            await this.loadScoreData();
            await this.loadMarketData();
            this.updateDisplay();
          } catch (error) {
            this.showError("Failed to load data: " + error.message);
          }
        }

        async loadScoreData() {
          // Add cache-busting parameter
          const timestamp = new Date().getTime();
          const response = await fetch(
            `scores/${this.selectedFile}?t=${timestamp}`,
          );
          const text = await response.text();

          const lines = text.trim().split("\n");
          const headers = lines[0].split("\t");

          this.scoreData = lines.slice(1).map((line) => {
            const values = line.split("\t");
            return {
              stock: values[0],
              score: parseFloat(values[1]),
              target: parseFloat(values[2]),
            };
          });

          // Initialize filtered stocks to all stocks (no filtering)
          this.filteredStocks = [...this.scoreData];
        }

        async loadMarketData() {
          const csvFile = this.selectedFile.replace(".tsv", ".csv");

          try {
            // Add cache-busting parameter
            const timestamp = new Date().getTime();
            const response = await fetch(
              `scores/${csvFile}?t=${timestamp}`,
            );
            const text = await response.text();

            if (!text.trim()) {
              this.marketData = null;
              return;
            }

            const lines = text.split("\n").filter((line) =>
              line.trim()
            );
            const headers = lines[0].split(",");

            this.marketData = {};

            lines.slice(1).forEach((line) => {
              const values = line.split(",");
              const date = values[0];
              const ticker = values[1];
              const high = parseFloat(values[2]);
              const low = parseFloat(values[3]);
              const open = parseFloat(values[4]);
              const close = parseFloat(values[5]);

              if (!this.marketData[ticker]) {
                this.marketData[ticker] = [];
              }

              this.marketData[ticker].push({
                date: new Date(date),
                high,
                low,
                open,
                close,
              });
            });

            // Load dividend data
            await this.loadDividendData();
          } catch (error) {
            console.warn(
              "No market data available yet:",
              error.message,
            );
            this.marketData = null;
          }
        }

        async loadDividendData() {
          const dividendFile = this.selectedFile.replace(
            ".tsv",
            "-dividends.csv",
          );

          try {
            // Add cache-busting parameter
            const timestamp = new Date().getTime();
            const response = await fetch(
              `scores/${dividendFile}?t=${timestamp}`,
            );
            const text = await response.text();

            if (!text.trim()) {
              this.dividendData = null;
              return;
            }

            const lines = text.split("\n").filter((line) =>
              line.trim()
            );
            const headers = lines[0].split(",");

            this.dividendData = {};

            lines.slice(1).forEach((line) => {
              const values = line.split(",");
              const exDivDate = values[0];
              const ticker = values[1];
              const amount = parseFloat(values[2]);

              if (!this.dividendData[ticker]) {
                this.dividendData[ticker] = [];
              }

              this.dividendData[ticker].push({
                exDivDate: new Date(exDivDate),
                amount,
              });
            });
          } catch (error) {
            console.warn(
              "No dividend data available:",
              error.message,
            );
            this.dividendData = null;
          }
        }

        updateDisplay() {
          if (!this.scoreData) {
            this.showError("No score data available");
            return;
          }

          if (
            !this.marketData ||
            Object.keys(this.marketData).length === 0
          ) {
            this.showNoData();
            return;
          }

          this.hideMessages();
          this.updateSummaryStats();
          this.updateChart();
          this.updateStockTable();

          // Show/hide back button based on view mode
          document.getElementById("backToAggregate").style.display =
            this.selectedStock ? "block" : "none";
        }

        updateSummaryStats() {
          const scoreFile = this.selectedFile;
          const scoreDate = this.getScoreDate(scoreFile);
          const daysElapsed = this.getDaysElapsed(scoreDate);

          document.getElementById("daysElapsed").textContent =
            daysElapsed;
          document.getElementById("stocksTracked").textContent =
            this.scoreData.length;

          const avgPerformance = this.calculateAveragePerformance();
          document.getElementById("avgPerformance").textContent =
            avgPerformance.toFixed(1) + "%";
        }

        getScoreDate(scoreFile) {
          // Extract date from filename like "2025/June/20.tsv"
          const match = scoreFile.match(/(\d{4})\/(\w+)\/(\d+)\.tsv/);
          if (match) {
            const [, year, month, day] = match;
            const monthIndex = new Date(`${month} 1, ${year}`)
              .getMonth();
            return new Date(parseInt(year), monthIndex, parseInt(day));
          }
          return new Date();
        }

        getDaysElapsed(scoreDate) {
          const today = new Date();
          const diffTime = Math.abs(today - scoreDate);
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
          return diffDays;
        }

        calculateAveragePerformance() {
          let totalPerformance = 0;
          let validStocks = 0;

          this.scoreData.forEach((stock) => {
            const performance = this.calculateStockPerformance(stock);
            if (performance !== null) {
              totalPerformance += performance;
              validStocks++;
            }
          });

          return validStocks > 0 ? totalPerformance / validStocks : 0;
        }

        calculateStockPerformance(stock) {
          const marketData = this.marketData[stock.stock];
          if (!marketData || marketData.length === 0) return null;

          // Get the latest price (midpoint between high and low)
          const latestData = marketData[marketData.length - 1];
          const currentPrice = (latestData.high + latestData.low) / 2;

          // Get the price on the score date as the buy price
          const scoreDate = this.getScoreDate(this.selectedFile);
          const scoreDateData = marketData.find((point) => {
            // Compare dates by day only, ignoring time components
            const pointDate = new Date(
              point.date.getFullYear(),
              point.date.getMonth(),
              point.date.getDate(),
            );
            const scoreDateOnly = new Date(
              scoreDate.getFullYear(),
              scoreDate.getMonth(),
              scoreDate.getDate(),
            );
            return pointDate.getTime() === scoreDateOnly.getTime();
          });
          const buyPrice = scoreDateData
            ? (scoreDateData.high + scoreDateData.low) / 2
            : stock.target;

          return ((currentPrice - buyPrice) / buyPrice) * 100;
        }

        updateChart() {
          const ctx = document.getElementById("performanceChart")
            .getContext("2d");

          if (this.chart) {
            this.chart.destroy();
          }

          const chartData = this.prepareChartData();
          const chartTitle = this.selectedStock
            ? `${this.selectedStock} Performance`
            : "Portfolio Performance Over Time";

          // Check if mobile device
          const isMobile = window.innerWidth <= 768;

          this.chart = new Chart(ctx, {
            type: "line",
            data: chartData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: {
                  display: true,
                  text: chartTitle,
                  font: {
                    size: isMobile ? 14 : 16,
                  },
                },
                legend: {
                  display: true,
                  labels: {
                    boxWidth: isMobile ? 12 : 16,
                    padding: isMobile ? 8 : 12,
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  callbacks: {
                    title: function (context) {
                      const date = new Date(context[0].parsed.x);
                      return date.toLocaleDateString();
                    },
                    label: function (context) {
                      const label = context.dataset.label || "";
                      const value = context.parsed.y;
                      const dataPoint = context.raw;

                      let tooltipText = "";
                      if (label.includes("Target")) {
                        tooltipText = `${label}: $${value.toFixed(2)}`;
                      } else if (label.includes("Actual")) {
                        tooltipText = `${label}: $${value.toFixed(2)}`;
                      } else {
                        tooltipText = `${label}: ${value.toFixed(1)}%`;
                      }

                      // Add dividend information if available
                      if (dataPoint && dataPoint.dividend) {
                        if (typeof dataPoint.dividend === "number") {
                          tooltipText += ` (Ex-Dividend: $${
                            dataPoint.dividend.toFixed(2)
                          })`;
                        } else {
                          tooltipText +=
                            ` (Ex-Dividend: ${dataPoint.dividend})`;
                        }
                      }

                      return tooltipText;
                    },
                  },
                },
              },
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "day",
                    displayFormats: {
                      day: isMobile ? "MMM d" : "MMM dd, yyyy",
                    },
                  },
                  title: {
                    display: true,
                    text: "Date",
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                  ticks: {
                    maxTicksLimit: isMobile ? 6 : 10,
                    font: {
                      size: isMobile ? 8 : 10,
                    },
                  },
                },
                y: {
                  type: "linear",
                  display: true,
                  position: "left",
                  title: {
                    display: true,
                    text: "Performance (%)",
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                  ticks: {
                    font: {
                      size: isMobile ? 8 : 10,
                    },
                  },
                },
                y1: {
                  type: "linear",
                  display: this.selectedStock, // Only show for single stock view
                  position: "right",
                  title: {
                    display: this.selectedStock,
                    text: "Price ($)",
                    font: {
                      size: isMobile ? 10 : 12,
                    },
                  },
                  ticks: {
                    font: {
                      size: isMobile ? 8 : 10,
                    },
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
              },
              plugins: {
                annotation: {
                  annotations: {
                    line1: {
                      type: "line",
                      xMin: this.getScoreDate(this.selectedFile),
                      xMax: this.getScoreDate(this.selectedFile),
                      borderColor: "rgba(255, 193, 7, 0.8)",
                      borderWidth: 2,
                      label: {
                        content: "Score Date",
                        enabled: true,
                        font: {
                          size: isMobile ? 8 : 10,
                        },
                      },
                    },
                    line2: {
                      type: "line",
                      yMin: 0,
                      yMax: 0,
                      borderColor: "rgba(108, 117, 125, 0.5)",
                      borderWidth: 1,
                      borderDash: [5, 5],
                    },
                    // Add 90-day target line
                    line3: {
                      type: "line",
                      xMin: new Date(
                        this.getScoreDate(this.selectedFile).getTime() +
                          (90 * 24 * 60 * 60 * 1000),
                      ),
                      xMax: new Date(
                        this.getScoreDate(this.selectedFile).getTime() +
                          (90 * 24 * 60 * 60 * 1000),
                      ),
                      borderColor: "rgba(220, 53, 69, 0.8)",
                      borderWidth: 2,
                      borderDash: [5, 5],
                      label: {
                        content: "90-Day Target",
                        enabled: true,
                        font: {
                          size: isMobile ? 8 : 10,
                        },
                      },
                    },
                  },
                },
              },
            },
          });
        }

        prepareChartData() {
          const datasets = [];
          const scoreDate = this.getScoreDate(this.selectedFile);
          const daysElapsed = this.getDaysElapsed(scoreDate);
          const ninetyDayDate = new Date(
            scoreDate.getTime() + (90 * 24 * 60 * 60 * 1000),
          );

          if (this.selectedStock) {
            // Single stock view
            const stock = this.scoreData.find((s) =>
              s.stock === this.selectedStock
            );
            if (stock) {
              const marketData = this.marketData[stock.stock];
              if (marketData && marketData.length > 0) {
                // Split data into before and after 90 days
                const before90Days = [];
                const after90Days = [];

                // Get the price on the score date as the buy price
                const scoreDateData = marketData.find((point) => {
                  // Compare dates by day only, ignoring time components
                  const pointDate = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const scoreDateOnly = new Date(
                    scoreDate.getFullYear(),
                    scoreDate.getMonth(),
                    scoreDate.getDate(),
                  );
                  return pointDate.getTime() ===
                    scoreDateOnly.getTime();
                });
                const buyPrice = scoreDateData
                  ? (scoreDateData.high + scoreDateData.low) / 2
                  : stock.target;

                // Get dividend data for this stock
                const stockDividends =
                  this.dividendData?.[stock.stock] || [];
                const exDivDates = stockDividends.map((d) =>
                  d.exDivDate.getTime()
                );

                marketData.forEach((point) => {
                  const dataPoint = {
                    x: point.date,
                    y: (((point.high + point.low) / 2 - buyPrice) /
                      buyPrice) * 100,
                  };

                  // Check if this is an ex-dividend date
                  const pointDateOnly = new Date(
                    point.date.getFullYear(),
                    point.date.getMonth(),
                    point.date.getDate(),
                  );
                  const isExDivDate = exDivDates.some((exDivTime) => {
                    const exDivDateOnly = new Date(
                      new Date(exDivTime).getFullYear(),
                      new Date(exDivTime).getMonth(),
                      new Date(exDivTime).getDate(),
                    );
                    return pointDateOnly.getTime() ===
                      exDivDateOnly.getTime();
                  });

                  // Add dividend info to tooltip
                  if (isExDivDate) {
                    const dividend = stockDividends.find((d) => {
                      const dDateOnly = new Date(
                        d.exDivDate.getFullYear(),
                        d.exDivDate.getMonth(),
                        d.exDivDate.getDate(),
                      );
                      return dDateOnly.getTime() ===
                        pointDateOnly.getTime();
                    });
                    if (dividend) {
                      dataPoint.dividend = dividend.amount;
                    }
                  }

                  if (point.date <= ninetyDayDate) {
                    before90Days.push(dataPoint);
                  } else {
                    after90Days.push(dataPoint);
                  }
                });

                // Add before 90 days data (normal color)
                if (before90Days.length > 0) {
                  datasets.push({
                    label: stock.stock,
                    data: before90Days,
                    borderColor: "rgba(102, 126, 234, 1)",
                    backgroundColor: "rgba(102, 126, 234, 0.1)",
                    borderWidth: 3,
                    fill: false,
                    pointRadius: before90Days.map((point) =>
                      point.dividend ? 8 : 3
                    ),
                    pointBackgroundColor: before90Days.map((point) =>
                      point.dividend
                        ? "rgba(0, 123, 255, 1)"
                        : "rgba(102, 126, 234, 1)"
                    ),
                    pointBorderColor: before90Days.map((point) =>
                      point.dividend
                        ? "rgba(0, 123, 255, 1)"
                        : "rgba(102, 126, 234, 1)"
                    ),
                    pointHoverRadius: before90Days.map((point) =>
                      point.dividend ? 12 : 6
                    ),
                  });
                }

                // Add after 90 days data (gray)
                if (after90Days.length > 0) {
                  datasets.push({
                    label: `${stock.stock} (After 90 Days)`,
                    data: after90Days,
                    borderColor: "rgba(108, 117, 125, 0.5)",
                    backgroundColor: "rgba(108, 117, 125, 0.1)",
                    borderWidth: 1,
                    fill: false,
                    pointRadius: after90Days.map((point) =>
                      point.dividend ? 8 : 3
                    ),
                    pointBackgroundColor: after90Days.map((point) =>
                      point.dividend
                        ? "rgba(0, 123, 255, 1)"
                        : "rgba(108, 117, 125, 0.5)"
                    ),
                    pointBorderColor: after90Days.map((point) =>
                      point.dividend
                        ? "rgba(0, 123, 255, 1)"
                        : "rgba(108, 117, 125, 0.5)"
                    ),
                    pointHoverRadius: after90Days.map((point) =>
                      point.dividend ? 12 : 6
                    ),
                  });
                }

                // Add target price as a single point at 90 days
                datasets.push({
                  label: "Target Price",
                  data: [{
                    x: ninetyDayDate,
                    y: stock.target,
                  }],
                  borderColor: "rgba(255, 193, 7, 0.8)",
                  backgroundColor: "rgba(255, 193, 7, 0.8)",
                  borderWidth: 3,
                  pointRadius: 6,
                  pointHoverRadius: 8,
                  fill: false,
                  showLine: false, // Don't connect points
                  yAxisID: "y1", // Use secondary Y-axis for prices
                });
              }
            }
          } else {
            // Aggregate view - show portfolio average
            const portfolioData = this.calculatePortfolioData();
            if (portfolioData.length > 0) {
              // Split portfolio data into before and after 90 days
              const before90Days = [];
              const after90Days = [];

              // Get all ex-dividend dates for aggregate view
              const allExDivDates = [];
              if (this.dividendData) {
                Object.values(this.dividendData).forEach(
                  (dividends) => {
                    dividends.forEach((d) => {
                      allExDivDates.push(d.exDivDate.getTime());
                    });
                  },
                );
              }

              portfolioData.forEach((point) => {
                // Check if this is an ex-dividend date
                const pointDateOnly = new Date(
                  point.x.getFullYear(),
                  point.x.getMonth(),
                  point.x.getDate(),
                );
                const isExDivDate = allExDivDates.some((exDivTime) => {
                  const exDivDateOnly = new Date(
                    new Date(exDivTime).getFullYear(),
                    new Date(exDivTime).getMonth(),
                    new Date(exDivTime).getDate(),
                  );
                  return pointDateOnly.getTime() ===
                    exDivDateOnly.getTime();
                });

                // Add dividend info to tooltip
                if (isExDivDate) {
                  const dividendsOnDate = [];
                  if (this.dividendData) {
                    Object.entries(this.dividendData).forEach(
                      ([stock, dividends]) => {
                        dividends.forEach((d) => {
                          const dDateOnly = new Date(
                            d.exDivDate.getFullYear(),
                            d.exDivDate.getMonth(),
                            d.exDivDate.getDate(),
                          );
                          if (
                            dDateOnly.getTime() ===
                              pointDateOnly.getTime()
                          ) {
                            dividendsOnDate.push(
                              `${stock}: $${d.amount.toFixed(2)}`,
                            );
                          }
                        });
                      },
                    );
                  }
                  if (dividendsOnDate.length > 0) {
                    point.dividend = dividendsOnDate.join(", ");
                  }
                }

                if (point.x <= ninetyDayDate) {
                  before90Days.push(point);
                } else {
                  after90Days.push(point);
                }
              });

              // Add before 90 days data (normal color)
              if (before90Days.length > 0) {
                datasets.push({
                  label: "Portfolio Average",
                  data: before90Days,
                  borderColor: "rgba(102, 126, 234, 1)",
                  backgroundColor: "rgba(102, 126, 234, 0.1)",
                  borderWidth: 3,
                  fill: false,
                  pointRadius: before90Days.map((point) =>
                    point.dividend ? 8 : 3
                  ),
                  pointBackgroundColor: before90Days.map((point) =>
                    point.dividend
                      ? "rgba(0, 123, 255, 1)"
                      : "rgba(102, 126, 234, 1)"
                  ),
                  pointBorderColor: before90Days.map((point) =>
                    point.dividend
                      ? "rgba(0, 123, 255, 1)"
                      : "rgba(102, 126, 234, 1)"
                  ),
                  pointHoverRadius: before90Days.map((point) =>
                    point.dividend ? 12 : 6
                  ),
                });
              }

              // Add after 90 days data (gray)
              if (after90Days.length > 0) {
                datasets.push({
                  label: "Portfolio Average (After 90 Days)",
                  data: after90Days,
                  borderColor: "rgba(108, 117, 125, 0.5)",
                  backgroundColor: "rgba(108, 117, 125, 0.1)",
                  borderWidth: 1,
                  fill: false,
                  pointRadius: after90Days.map((point) =>
                    point.dividend ? 8 : 3
                  ),
                  pointBackgroundColor: after90Days.map((point) =>
                    point.dividend
                      ? "rgba(0, 123, 255, 1)"
                      : "rgba(108, 117, 125, 0.5)"
                  ),
                  pointBorderColor: after90Days.map((point) =>
                    point.dividend
                      ? "rgba(0, 123, 255, 1)"
                      : "rgba(108, 117, 125, 0.5)"
                  ),
                  pointHoverRadius: after90Days.map((point) =>
                    point.dividend ? 12 : 6
                  ),
                });
              }

              // Add target price as a single point at 90 days for aggregate view
              const avgTarget = this.scoreData.reduce((sum, stock) =>
                sum + stock.target, 0) / this.scoreData.length;
              const targetReturn = 20; // 20% target

              datasets.push({
                label: "Target Price",
                data: [{
                  x: ninetyDayDate,
                  y: targetReturn,
                }],
                borderColor: "rgba(255, 193, 7, 0.8)",
                backgroundColor: "rgba(255, 193, 7, 0.8)",
                borderWidth: 3,
                pointRadius: 6,
                pointHoverRadius: 8,
                fill: false,
                showLine: false, // Don't connect points
              });
            }
          }

          // Add cost of capital line (remove dots)
          const costOfCapitalData = this.calculateCostOfCapitalData();
          if (costOfCapitalData.length > 0) {
            datasets.push({
              label: "Cost of Capital",
              data: costOfCapitalData,
              borderColor: "rgba(108, 117, 125, 0.8)",
              backgroundColor: "rgba(108, 117, 125, 0.1)",
              borderWidth: 2,
              fill: false,
            });
          }

          return { datasets };
        }

        calculatePortfolioData() {
          const scoreDate = this.getScoreDate(this.selectedFile);
          const portfolioData = [];

          // Get all unique dates from market data
          const allDates = new Set();
          this.scoreData.forEach((stock) => {
            const marketData = this.marketData[stock.stock];
            if (marketData) {
              marketData.forEach((point) =>
                allDates.add(point.date.getTime())
              );
            }
          });

          const sortedDates = Array.from(allDates).sort((a, b) =>
            a - b
          );

          sortedDates.forEach((timestamp) => {
            const date = new Date(timestamp);
            let totalPerformance = 0;
            let validStocks = 0;

            this.scoreData.forEach((stock) => {
              const marketData = this.marketData[stock.stock];
              if (marketData) {
                const dataPoint = marketData.find(
                  (point) => point.date.getTime() === timestamp,
                );
                if (dataPoint) {
                  // Get the price on the score date as the buy price
                  const scoreDateData = marketData.find((point) => {
                    // Compare dates by day only, ignoring time components
                    const pointDate = new Date(
                      point.date.getFullYear(),
                      point.date.getMonth(),
                      point.date.getDate(),
                    );
                    const scoreDateOnly = new Date(
                      scoreDate.getFullYear(),
                      scoreDate.getMonth(),
                      scoreDate.getDate(),
                    );
                    return pointDate.getTime() ===
                      scoreDateOnly.getTime();
                  });
                  const buyPrice = scoreDateData
                    ? (scoreDateData.high + scoreDateData.low) / 2
                    : stock.target;

                  totalPerformance +=
                    (((dataPoint.high + dataPoint.low) / 2 - buyPrice) /
                      buyPrice) * 100;
                  validStocks++;
                }
              }
            });

            if (validStocks > 0) {
              portfolioData.push({
                x: date,
                y: totalPerformance / validStocks,
              });
            }
          });

          return portfolioData;
        }

        calculateCostOfCapitalData() {
          const scoreDate = this.getScoreDate(this.selectedFile);
          const costOfCapitalData = [];

          // Get all unique dates from market data
          const allDates = new Set();
          this.scoreData.forEach((stock) => {
            const marketData = this.marketData[stock.stock];
            if (marketData) {
              marketData.forEach((point) =>
                allDates.add(point.date.getTime())
              );
            }
          });

          const sortedDates = Array.from(allDates).sort((a, b) =>
            a - b
          );

          sortedDates.forEach((timestamp) => {
            const date = new Date(timestamp);
            const daysSinceScore = (date - scoreDate) /
              (1000 * 60 * 60 * 24);
            const costOfCapitalReturn = (this.costOfCapital / 365) *
              daysSinceScore;

            costOfCapitalData.push({
              x: date,
              y: costOfCapitalReturn,
            });
          });

          return costOfCapitalData;
        }

        getColor(index, alpha = 1) {
          const colors = [
            `rgba(220, 53, 69, ${alpha})`, // Red
            `rgba(40, 167, 69, ${alpha})`, // Green
            `rgba(255, 193, 7, ${alpha})`, // Yellow
            `rgba(23, 162, 184, ${alpha})`, // Cyan
            `rgba(111, 66, 193, ${alpha})`, // Purple
          ];
          return colors[index % colors.length];
        }

        updateStockTable() {
          const tbody = document.getElementById("stockTableBody");
          tbody.innerHTML = "";

          this.scoreData.forEach((stock) => {
            const row = document.createElement("tr");
            const performance = this.calculateStockPerformance(stock);
            const judgement = this.calculateJudgement(
              stock,
              performance,
            );

            // Get dividend information
            const dividends = this.dividendData?.[stock.stock] || [];
            const totalDividends = dividends.reduce(
              (sum, div) => sum + div.amount,
              0,
            );
            const dividendInfo = dividends.length > 0
              ? `$${
                totalDividends.toFixed(2)
              } (${dividends.length} div${
                dividends.length > 1 ? "s" : ""
              })`
              : "None";

            row.innerHTML = `
              <td class="clickable-stock" onclick="validator.showStockDetails('${stock.stock}')">${stock.stock}</td>
              <td>$${stock.target.toFixed(2)}</td>
              <td>$${(stock.target * 1.2).toFixed(2)}</td>
              <td>${this.getCurrentPrice(stock.stock)}</td>
              <td class="${this.getPerformanceClass(performance)}">${
              performance !== null
                ? performance.toFixed(1) + "%"
                : "N/A"
            }</td>
              <td class="${this.getPerformanceClass(performance)}">${
              this.calculateProgressVsCostOfCapital(stock, performance)
            }</td>
              <td><span class="badge ${
              this.getJudgementClass(judgement)
            }">${judgement}</span></td>
              <td>${dividendInfo}</td>
            `;

            tbody.appendChild(row);
          });
        }

        getCurrentPrice(stockSymbol) {
          const marketData = this.marketData[stockSymbol];
          if (!marketData || marketData.length === 0) return "N/A";
          const latestData = marketData[marketData.length - 1];
          const currentPrice = (latestData.high + latestData.low) / 2;
          return "$" + currentPrice.toFixed(2);
        }

        calculateProgressVsCostOfCapital(stock, performance) {
          if (performance === null) return "N/A";

          const scoreDate = this.getScoreDate(this.selectedFile);
          const daysElapsed = this.getDaysElapsed(scoreDate);
          const costOfCapitalReturn = (this.costOfCapital / 365) *
            daysElapsed;

          const excessReturn = performance - costOfCapitalReturn;
          return excessReturn.toFixed(1) + "%";
        }

        calculateJudgement(stock, performance) {
          if (performance === null) return "Pending";

          const targetReturn = 20; // 20% target
          const threshold = targetReturn * 0.8; // 80% of target

          if (performance >= threshold) {
            return "Hit Target";
          } else if (performance > 0) {
            return "Partial Success";
          } else {
            return "Missed Target";
          }
        }

        getPerformanceClass(performance) {
          if (performance === null) return "performance-neutral";
          return performance >= 0
            ? "performance-positive"
            : "performance-negative";
        }

        getJudgementClass(judgement) {
          switch (judgement) {
            case "Hit Target":
              return "judgement-hit";
            case "Partial Success":
              return "judgement-partial";
            case "Missed Target":
              return "judgement-miss";
            default:
              return "bg-secondary";
          }
        }

        showStockDetails(stockSymbol) {
          this.selectedStock = stockSymbol;
          this.updateDisplay();

          // Show the back button
          document.getElementById("backToAggregate").style.display =
            "block";
        }

        showLoading() {
          document.getElementById("loading").style.display = "block";
          document.getElementById("summary").style.display = "none";
          document.getElementById("error").style.display = "none";
          document.getElementById("noData").style.display = "none";
        }

        showError(message) {
          document.getElementById("loading").style.display = "none";
          document.getElementById("summary").style.display = "none";
          document.getElementById("noData").style.display = "none";
          document.getElementById("error").style.display = "block";
          document.getElementById("error").textContent = message;
        }

        showNoData() {
          document.getElementById("loading").style.display = "none";
          document.getElementById("summary").style.display = "none";
          document.getElementById("error").style.display = "none";
          document.getElementById("noData").style.display = "block";
        }

        hideMessages() {
          document.getElementById("loading").style.display = "none";
          document.getElementById("error").style.display = "none";
          document.getElementById("noData").style.display = "none";
          document.getElementById("summary").style.display = "block";
        }
      }

      // Initialize the validator
      const validator = new GRQValidator();
    </script>
  </body>
</html>
